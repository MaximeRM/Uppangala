---
title: "Uppangala trees functionnal traits : Exploration"
author: "Sylvain Schmitt"
date: '`r Sys.Date()`'
output: html_document
fig_caption: yes
vignette: |
  %\VignetteIndexEntry{Uppangala PFT} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---

```{r config, message=FALSE, warning=FALSE, include=FALSE}
library(knitr)
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 8, fig.width = 8,
  cache = T, cache.lazy = F)
```

# Traits

## Data cleaning

### Load data

Data loading from gen functions, that open data from raw tables in `inst/extdata`

```{r Load data}
rm(list = ls()); invisible(gc())
library(Uppangala)
PFT <- genPFT()
captions <- genCaptions()
```

#### Uncorrectable errors

Errors in PFT values :

* Wood density > 1, being Gummi gutta sample P5.122 to small to measure a correct wood density
* Thickness outliers due to veins but correct entered data

### Outlier research

```{r variances}
par(mfrow = c(1,1))
bymedian <- with(PFT, reorder(Sp_Code, -Thick,  mean, na.rm = T))
boxplot(Thick ~ bymedian, data = PFT, las = 2, horizontal = F, main = captions['Thick'])
bymedian <- with(PFT, reorder(Sp_Code, -LA,  mean, na.rm = T))
boxplot(log(LA) ~ bymedian, data = PFT, las = 2, horizontal = F, main = captions['log(LA)'])
bymedian <- with(PFT, reorder(Sp_Code, -LDMC,  mean, na.rm = T))
boxplot(LDMC ~ bymedian, data = PFT, las = 2, horizontal = F, main = captions['LDMC'])
bymedian <- with(PFT, reorder(Sp_Code, -SLA,  mean, na.rm = T))
boxplot(log(SLA) ~ bymedian, data = PFT, las = 2, horizontal = F, main = captions['log(SLA)'])
bymedian <- with(PFT, reorder(Sp_Code, -log(SHA),  mean, na.rm = T))
boxplot(log(SHA) ~ bymedian, data = PFT, las = 2, horizontal = F, main = captions['log(SHA)'])
bymedian <- with(PFT, reorder(Sp_Code, -WD,  mean, na.rm = T))
boxplot(WD ~ bymedian, data = PFT, las = 2, horizontal = F, main = captions['WD'])
bymedian <- with(PFT, reorder(Sp_Code, -LTD,  median, na.rm = T))
boxplot(LTD ~ bymedian, data = PFT, las = 2, horizontal = F, main = captions['LTD'])
rm(bymedian)
```

### Leaf Principal component analysis

```{r Leaf PCA}
# pca <- princomp(~ LA + WD + Thick + LDMC + LTD + SLA + SHA, data = PFT, cor = T)
pca <- princomp(~ LA + WD + Thick + LDMC + SLA + SHA, data = PFT, cor = T)
par(mfrow = c(1,1))
col = rainbow(93)[as.numeric(PFT[row.names(pca$scores),3])]
plot(pca$scores[,1:2], pch = 16, cex = 0.6, col = col)
rm(col, pca)
```

## Traits informations

#### Distributions

```{r distributions}
par(mfrow = c(1,1))
hist(PFT$Thick, prob = T)
lines(density(PFT$Thick, na.rm = T), col = "red")
hist(log(PFT$LA), prob = T)
lines(density(log(PFT$LA), na.rm = T), col = "red")
hist(PFT$LDMC, prob = T)
lines(density(PFT$LDMC, na.rm = T), col = "red")
# hist(PFT$LTD, prob = T)
# lines(density(PFT$LTD, na.rm = T), col = "red")
hist(log(PFT$SLA), prob = T)
lines(density(log(PFT$SLA), na.rm = T), col = "red")
hist(log(PFT$SHA), prob = T)
lines(density(log(PFT$SHA), na.rm = T), col = "red")
hist(PFT$WD, prob = T)
lines(density(PFT$WD, na.rm = T), col = "red")
```

### Individual aggregation and coefficient of variation

```{r Individual aggragetion, echo = T}
PFT_ind <- aggregate(PFT, by = list(PFT$Tree), FUN = mean, na.rm = T)
row.names(PFT_ind) <- PFT_ind$Group.1
SpT <- unique(PFT[1:2])
Sp <- SpT$SP
names(Sp) <- SpT$Tree
SpCodeT <- unique(PFT[2:3])
SpCode <- SpCodeT$Sp_Code
names(SpCode) <- SpCodeT$SP
CET <- unique(PFT[c(1,4)])
CE <- CET$CE
names(CE) <- CET$Tree
PFT_ind$SP <- Sp[row.names(PFT_ind)]
PFT_ind$Sp_Code <- SpCode[as.character(PFT_ind$SP)]
PFT_ind$CE <- CE[row.names(PFT_ind)]
PFT_ind <- PFT_ind[-c(1:2)]
rm(SpT, Sp, SpCodeT, CET, CE)
```

### Coefficient of variation
```{r CV}
cv <- data.frame(row.names = c('Thick', 'LA', 'LDMC', 'SLA', 'WD'))
cv$Individual <- unlist(lapply(
  as.list(row.names(cv)), 
  function(y){mean(aggregate(PFT[which(names(PFT) ==  y)], by = list(PFT$Tree), function(x){sd(x, na.rm = T) / mean(x, na.rm = T)})[,2], na.rm = T)}))
cv$Species <- unlist(lapply(
  as.list(row.names(cv)), 
  function(y){mean(aggregate(PFT_ind[which(names(PFT_ind) ==  y)], by = list(PFT_ind$SP), function(x){sd(x, na.rm = T) / mean(x, na.rm = T)})[,2], na.rm = T)}))
cv$Community <- unlist(
  lapply(as.list(row.names(cv)), 
         function(y){sd(PFT[,which(names(PFT) ==  y)], na.rm = T) /
             mean(PFT[,which(names(PFT) ==  y)], na.rm = T)}))                 
cv <- round(cv, 2)
cv['WD','Individual'] <- ''
knitr::kable(cv)
rm(cv, PFT)
```

### Tree Principal component analysis

```{r Tree PCA}
library(vegan)
# pca <- princomp(~ LA + WD + Thick + LDMC + LTD + SLA, data = PFT_ind, cor = T)
pca <- princomp(~ LA + WD + Thick + LDMC + SLA, data = PFT_ind, cor = T)
par(mfrow = c(1,1))
pca.var = apply(pca$score, 2, var)
barplot((pca.var / sum(pca.var)), las = 2, 
        main = 'StdInertia', ylim = c(0,range(bstick(7))[2]))
lines(bstick(6), col = 'red')
legend('bottomleft', c('PCA', 'broken stick'), fill = c('grey', 'red'))
biplot(pca, col = c('grey', 'red'), choices = c(1,2))
PCAscores <- as.data.frame(pca$scores)[1:3] # Adding PCA axis in PFT values
names(PCAscores) <- c('PCA1', 'PCA2', 'PCA3')
PCAscores$ID <- row.names(PCAscores)
PFT_ind$ID <- row.names(PFT_ind)
PFT_ind <- merge(PFT_ind, PCAscores, all = T)
row.names(PFT_ind) <- PFT_ind$ID
PFT_ind <- PFT_ind[-which(names(PFT_ind) == 'ID')]
rm(pca.var, PCAscores)
```


### Traits relations

```{r Traits relations}
library(smatr)
par(mfrow = c(2,2))
PFTrel("LDMC", "Thick", PFT_ind, captions, cex = 0.7)
PFTrel("LDMC", "WD", PFT_ind, captions)
PFTrel("LDMC", "log(SLA)",  PFT_ind, captions)
PFTrel("Thick", "log(SLA)",  PFT_ind, captions)
PFTrel('log(LA)', "LDMC", PFT_ind, captions)
PFTrel('log(LA)', "WD", PFT_ind, captions)
PFTrel('log(LA)', "Thick", PFT_ind, captions)
X = PFT_ind$SLA*PFT_ind$LDMC
Y = PFT_ind$Thick
plot(Y ~ X, xlab = paste(captions['SLA'], 'x', captions['LDMC']), ylab = captions['Thick'], main = 'Thick ~ (SLA*LDMC)')
abline(sma(Y ~ X), col = 'red')
mtext(paste('Standardized Major Axis : R\u00b2 =',round(sma(Y ~ X)$r2[[1]], 2)), 1, col = 'red')
c <- cor.test(X, Y, method = 'spearman')
mtext(paste('Spearman\'s correlation : cor =', round(c$estimate, 2), stars(c$p.value)) , 3, col = 'blue')
rm(c, X, Y)
```

### Crown exposure effect

```{r CE, eval=FALSE, include=FALSE}
library(lme4)
CEtest <- data.frame(pca1 = pca$scores[,1],
                     CEs = PFT_ind[row.names(pca$scores),which(names(PFT) == 'CEs')],
                     Sp = PFT_ind[row.names(pca$scores),3])
CEtest <- CEtest[-which(is.na(CEtest$CEs)),]
m0 <- lmer(pca1 ~ CEs + (1 | CEs), CEtest)
m1 <- lmer(pca1 ~ CEs + (Sp | CEs), CEtest)
anova(m0, m1)
rm(CEtest)
```

# Environment

## Load data

```{r Load env}
library(raster)
Env <- genEnv()
Trees <- genTrees()
Species <- genSpecies()
hillshade <- DEMderiv(Env$DEM, c("slope", "aspect", "hillshade"))$Hillshade # For plotting purposes
```

## Trees
```{r Trees plot}
par(mfrow = c(1,1))
plot(hillshade, col = grey(0:100/100), main = 'Trees ~ Girth + Sp')
points(Y ~ X, Trees, col = SpCode, cex = `2013_girth`/100, pch = 20)
legend("bottomleft", legend = 'Species', fill = 'lightgrey')
```

## Traits

```{r Species aggregation}
PFT_sp <- aggregate(PFT_ind, by = list(PFT_ind$SP), FUN = mean, na.rm = T)
row.names(PFT_sp) <- PFT_sp$Group.1
PFT_sp$Sp_Code <- SpCode[row.names(PFT_sp)]
PFT_sp <- PFT_sp[-c(1:2,4)]
Trees$SpCode <- tolower(Trees$SpCode)
rm(PFT_ind)
setdiff(PFT_sp$Sp_Code, Trees$SpCode)
setdiff(Trees$SpCode, PFT_sp$Sp_Code)
```

Difference between species

* Agrosystachis indica (agin) is not yet registered in the database
* Toona ciliata (toci) is not yet removed from the database
* We didn't collect 25 rare species from Uppangala plots

```{r Merging Trees and traits, echo = T}
Trees$ID <- row.names(Trees)
l <- length(row.names(Trees))
Trees <- merge(Trees, PFT_sp, by.x = 'SpCode', by.y = 'Sp_Code')
row.names(Trees) <- Trees$ID
Trees <- Trees[-which(names(Trees) == 'ID')]
l - length(row.names(Trees))
rm(l)
```

There is 91 trees in missing species of our PFT dataset.

```{r Plot WD}
plot(hillshade, col=grey(0:100/100), main = 'Trees ~ Girth + WD')
col = heat.colors(100)[as.numeric(cut(Trees$WD, breaks = 100))]
points(Y ~ X, Trees, col = "black", cex = `2013_girth`/100, pch = 20)
points(Y ~ X, Trees, cex = `2013_girth`/100, pch = 20, col = col)
legend("bottomleft", legend = captions['WD'], fill = 'orange')
rm(col)
```

# Null Models

## Communities

Community definition by quadrat

```{r Communities, echo = T}
com <- quadrats()
Trees$com <- NA
XY <- data.frame(X = Trees$X, Y = Trees$Y)
XY <- XY[-which(is.na(XY$X)),] # Removing NA
coordinates(XY) <- ~ X + Y
proj4string(XY) <- crs(com)
Trees$com[which(!is.na(Trees$X))] <- (XY %over% com)[,1]
Trees$com[which(!is.na(Trees$com))] <- paste0('C', Trees$com[which(!is.na(Trees$com))])
```
```{r Plot com}
plot(hillshade, col=grey(0:100/100), main = 'Communities')
plot(as(com, "SpatialPolygons"), add = T)
col =  sample(rainbow(length(levels(as.factor(Trees$com)))))[as.numeric(as.factor(Trees$com))]
points(Y ~ X, Trees, cex = `2013_girth`/100, pch = 20, col = col)
legend("bottomleft", legend = 'community', fill = 'grey')
rm(col, XY, Trees_bin)
```

Some species distribtuion for SLA and WD by community

```{r dist com}
library(cati)
par(mfrow = c(4,4), cex = 0.5)
rows = which(Trees$com %in% sample(levels(as.factor(Trees$com)), 8))
plotDistri(as.matrix(Trees$SLA[rows]), Trees$com[rows], Trees$SpCode[rows],
           ylim.cex = 3, plot.ask = F, multipanel = F, leg = F, xlim = c(0, 35))
plotDistri(as.matrix(Trees$WD[rows]), Trees$com[rows], Trees$SpCode[rows],
           ylim.cex = 3, plot.ask = F, multipanel = F, leg = F, xlim = c(0.3, 0.85))
rm(rows)
```

Adding topo to communities

```{r com topo}
com@data$id <- paste0('C', com@data$id)
com@data$DEM <- extract(Env$DEM, as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
Deriv <- DEMderiv(raster(com, 'DEM'), c('slope', 'curvature', 'plancurvature', 'profcurvature', 'aspect'))
com@data <- cbind(com@data, extract(Deriv, as(com, "SpatialPolygons"), df = T, fun = mean)[-1])
com@data$Wetness <- extract(DEMderiv(Env$DEM, 'wetness'), as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
com@data$SouthWesterness <- sin((com@data$Aspect + 225) / 180 * pi)
com@data$NorthEasterness <- cos((com@data$Aspect + 225) / 180 * pi)
com@data$Rivers <- extract(Env$Rivers, as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
rm(Deriv)
```

PCA on topgraphical variables
```{r topo pca}
pca <- princomp(~ DEM + Slope + Curvature + PlanCurvature + ProfileCurvature + Wetness + Rivers + SouthWesterness, data = com@data, cor = T)
lambda <- pca$sdev * sqrt(nrow(pca$scores))
pca.var = apply(pca$score, 2, var)
plot(t(t(pca$scores)/lambda),pch=16, col = 'lightgrey',
     xlab = paste('Axe 1 -', round(lambda[1]/sum(lambda)*100, 2), '%'),
     ylab = paste('Axe 2 -', round(lambda[2]/sum(lambda)*100, 2), '%'))
Hmisc::subplot(function(){
  b <- barplot((pca.var / sum(pca.var)), las = 2,
          cex.names = 0.7, axes = T, names.arg = NA) ;
  lines(b, bstick(length(pca.var)), col = 'red') ;
  legend('topright', c('Eigen values', 'broken stick'), fill = c('grey', 'red'), cex = 0.6,
         box.col = 'white')},
  x=grconvertX(c(0.05,0.35), from='npc'),
  y=grconvertY(c(0.025,0.30), from='npc')
)
par(new=T)
Rot <- t(t(pca$loadings)*lambda)
XLIM <- c(-max(abs(Rot[,1])),max(abs(Rot[,1])))
XLIM <- XLIM+(XLIM*0.2)
plot(Rot,col=4,axes=FALSE,xlim=XLIM,ylim=XLIM,pch="",xlab = "", ylab = "")
lines(XLIM, c(0,0), lty = 2, lwd = 2)
lines(c(0,0), XLIM, lty = 2, lwd = 2)
col <- c("#1874CD", "#008B00", "#CD3700", "#9400D3")[c(2, 3, 1, 1, 1,  2, 1, 4)]
arrows (rep(0,nrow(pca$loadings)),rep(0,nrow(pca$loadings)),Rot[,1],Rot[,2],lwd=2,col=col)
legend('topright', c('Elevation', 'Slope', 'Water flow', 'South-West'),
       text.col = col, cex = 1.2)
text (Rot[,1:2], pos = c(2, 2, 2, 1, 1, 3, 3, 1), rownames(Rot),cex=1.2,col=col)
axis (3)
axis (4)
PCAscores <- as.data.frame(pca$scores)[1:3] # Adding PCA axis in PFT values
names(PCAscores) <- c('PCA1', 'PCA2', 'PCA3')
PCAscores$ID <- row.names(PCAscores)
```


Topographical classes assignation and plot

```{r Plot topo}
com@data$topo <- as.factor(with(com@data, topo_classes(Slope, Curvature, Aspect)))
par(mfrow = c(1,1))
col <- c("#008B00", "#00CD00", "#009ACD", "#00BFFF", "#CD9B1D", "#FFC125")
# col <- terrain.colors(7)[c(1,2,5,6,3,4)]
plot(raster(com, 'topo'), col = col, main = 'Topographical classes', legend = F)
contour(Env$DEM, add = T)
legend('bottomleft', fill = col, legend = levels(com@data$topo), cex = 0.7)
rm(col)
```

Adding CWM to communities
```{r CWM}
CWM <- aggregate(Trees, by = list(Trees$com), mean, na.rm = T) #CWM abundance
names(CWM)[1] <- 'id'
CWM <- CWM[which(names(CWM) %in% c('id', 'Thick', 'LA', 'LDMC', 'SLA', 'WD', 'PCA1', 'PCA2', 'PCA3'))]
com_abund <- merge(com, CWM)
Trees_bin <- Trees[-which(duplicated(cbind(Trees$SpCode, Trees$com))),] #CWM binary
CWM <- aggregate(Trees_bin, by = list(Trees_bin$com), mean, na.rm = T)
names(CWM)[1] <- 'id'
CWM <- CWM[which(names(CWM) %in% c('id', 'Thick', 'LA', 'LDMC', 'SLA', 'WD', 'PCA1', 'PCA2', 'PCA3'))]
com_bin <- merge(com, CWM)
library(plyr)
TreesBA <- Trees[-which(is.na(Trees$`2013_girth`)),] #CWM ba
CWM <- ddply(TreesBA, .(com), function(x){
  weighted.mean(x$SLA, x$`2013_girth`/2*pi, na.rm = T)})
CWM <- data.frame(id = CWM$com,
                  Thick = CWM$V1,
                  LA = ddply(TreesBA, .(com), function(x){weighted.mean(x$LA, x$`2013_girth`/2*pi, na.rm = T)})[,2],
                  LDMC = ddply(TreesBA, .(com), function(x){weighted.mean(x$LDMC, x$`2013_girth`/2*pi, na.rm = T)})[,2],
                  SLA = ddply(TreesBA, .(com), function(x){weighted.mean(x$SLA, x$`2013_girth`/2*pi, na.rm = T)})[,2],
                  WD = ddply(TreesBA, .(com), function(x){weighted.mean(x$WD, x$`2013_girth`/2*pi, na.rm = T)})[,2],
                  PCA1 = ddply(TreesBA, .(com), function(x){weighted.mean(x$PCA1, x$`2013_girth`/2*pi, na.rm = T)})[,2],
                  PCA2 = ddply(TreesBA, .(com), function(x){weighted.mean(x$PCA2, x$`2013_girth`/2*pi, na.rm = T)})[,2],
                  PCA3 = ddply(TreesBA, .(com), function(x){weighted.mean(x$PCA3, x$`2013_girth`/2*pi, na.rm = T)})[,2])
com_ba <- merge(com, CWM)
plot(gstat::variogram(WD~1, as(com_abund, 'SpatialPointsDataFrame'))) # 1 variogram
```

## Filters

Linear regression & Null models on all variables

```{r lm}
reg <- '~ DEM + Slope + Curvature + PlanCurvature + ProfileCurvature + Wetness + Rivers + SouthWesterness'
LM <- lapply(list(com_abund, com_bin, com_ba), 
             function(x) {with(x@data, list(PCA1 = lm(formula(paste('PCA1', reg))),
                                            PCA2 = lm(formula(paste('PCA2', reg))),
                                            PCA3 = lm(formula(paste('PCA3', reg))),
                                            logSLA = lm(formula(paste('log(SLA)', reg))),
                                            LDMC = lm(formula(paste('LDMC', reg))),
                                            # LTD = lm(formula(paste('LTD', reg))),
                                            logLA = lm(formula(paste('log(LA)', reg))),
                                            Thick = lm(formula(paste('Thick', reg))),
                                            WD = lm(formula(paste('WD', reg)))))})
names(LM) <- c('Abundance', 'Presence / Absence', 'Basal area')
cat('Shapiro test p-values :\n') ; unlist(lapply(LM, function(y){lapply(y, function(x){stars(shapiro.test(x$residuals)$p.value)})})) # Homoscedasticity
LM <- lapply(LM, function(y){lapply(y, function(x){step(x, direction = 'both', trace = 0)})})
# lapply(LM, function(x){lapply(x, summary)}) # No need with summary table
```

Null models

```{r Model, eval=FALSE, include=FALSE}
TreesL <- list(Trees, Trees_bin, TreesBA)
comL <- list(com_abund, com_bin, com_ba)
baL <- list(F, F, T)
model <- mapply(function(lm, trees, com, ba){
  null_model(formulas = lapply(lm, function(x){as.character(x$call)[2]}), 
             ba = ba, test = 'lm deviance', PFT_sp = PFT_sp, Trees = trees, 
             com = com, SpCode = SpCode, n = 1000, plot = F, count = F, time = T)},
  LM, TreesL, comL, baL, SIMPLIFY = F)
# lapply(model, function(x){
#   par(mfrow = c(2,4))
#   for(i in 1:8){
#     plot_model(x, index = i)
#   }
# })
res <- regression_table(LM, model, reg)
View(res)
knitr::kable(res)
```

Anova with topographical classes

```{r anova, eval=FALSE, include=FALSE}
ANOVA <- with(com@data, list(PCA1 = aov(PCA1 ~ topo),
                             PCA2 = aov(PCA2 ~ topo),
                             PCA3 = aov(PCA3 ~ topo),
                             SLA = aov(SLA ~ topo),
                             LDMC = aov(LDMC ~ topo),
                             # LTD = aov(LTD ~ topo),
                             LA = aov(LA ~ topo),
                             Thick = aov(Thick ~ topo),
                             WD = aov(WD ~ topo)))
cat('ANOVA p-values :\n') ; unlist(lapply(ANOVA, function(x){stars(summary(x)[[1]][['Pr(>F)']][1])}))
ANOVA <- ANOVA[which(lapply(ANOVA, function(x){summary(x)[[1]][['Pr(>F)']][1]}) < 0.05)]
lapply(ANOVA, TukeyHSD)
rm(ANOVA)
```

---
title: Decoupled wood and leaf strategies among canopy and understorey tree in a low-elevation rainforest of India
author: "Sylvain Schmitt sylvain.schmitt@agroparistech.fr"
date: '`r Sys.Date()`'
csl: mee.csl
bibliography: refs.bib
knit: "bookdown::render_book"
output:
  bookdown::gitbook
  # bookdown::pdf_book
  # word_document
---

```{r config, message=FALSE, warning=FALSE, include=FALSE}
rm(list = ls()); invisible(gc())
library(knitr)
library(parallel)
library(Uppangala)
library(broom)
library(vegan)
library(dplyr)
library(reshape2)
library(ggplot2)
library(ggfortify)
cores <- detectCores() - 1
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 8, fig.width = 8,
  cache = T, cache.lazy = F)
cv <- function(x, na.rm = T)
  sd(x, na.rm = na.rm)/mean(x, na.rm = na.rm)
path <- '~/Documents/IFP/Uppangala/inst/doc/draft_save/'
n = 999 # Random repetitions
```

# Introduction {-}

In this study, we used a trait-based approach to study separately the assembly of canopy and understorey tree species along topographical and biotic gradients in a large forest plot (10ha) loacted in Western Ghats biodiversity hotspot (Myers et al. 2000), India. Low elevation rainforests in South India are remarkably heterogeneous in vertical structure and encompass distinctive guilds across the vertical strata (Pascal 1988). It thus provides an appropriate context to adress guild-dependent assembly rules and ecological strategies in tropical rainforests. Although considered as wet evergreen, the forest undergoes contrasted long dry and intense rainy seasons under the influence of monsoon. In this context, we expected water stress and competition for resource to be important drivers of tree functional composition. We investigated how both canopy and understorey tree species composition varied with local environmental conditions, using appropriate null models. We specifically addressed the following questions:

* Does functional traits variation and covariation reflect basic dimensions of ecological strategy in the
rainforest ?
* Does the local functional composition reflect the influence of abiotic and biotic drivers of community
dynamics within guilds ?

In this document I will only briefly present all analysis, one by one, with their methods and results but without any discussion.

# Data

We used functional traits describe in table \@ref(tab:Traits) gathered in Uppangala forest among 89 species. In subsequent analysis we used log transformation of LA and SLA.

```{r Traits}
PFT <- genPFT()
kable(data.frame(
  Trait = c('Leaf thickness', 'Leaf area', 'Leaf dry matter content', 'Specific leaf area', 'Wood density'),
  Abbreviation = c('LT', 'LA', 'LDMC', 'SLA', 'WD'),
  Unit = c('$\\mu m$', '$mm^2$', '$mg.g^-1$', '$m^2.kg^-1$', '$g.cm^-3$'),
  Strategy = c('Leaf defense and investment',
        'Leaf resource capture vs.investment',
        'Leaf defense and investment',
        'Leaf resource acquisiton vs. defense',
        'Stem transport, structure and defense')
), caption = 'Functional traits measured. Traits with their abbreviation, standard unit, and associated species strategy for functioning, survival and reproduction [@baraloto_decoupled_2010].')
```

# Trait variation and covariation

## Coefficients of variation

We calculated coefficient of variations of trait values among leaves of the same individual (intra-individual), among trees of the same species (intra-specific for species with more than one individual), and among species (inter-specific) with following formula :
$$Coefficient~of~Variation = \frac{standard~deviation}{mean} $$

We found an overall increase of functional trait variation from intra-individual to inter-specific levels (see table \@ref(tab:CV)), even though LA showed almost as large variability at intra-individual than at intra-specific levels (CV individual = 0.20 and CV species = 0.24, wilcoxon rank test p − value = 0.137).

```{r CV}
PFT %>% 
  select(-Tree, -Sp, -SpCode, -CE, -SHA, -LTD) %>% 
  melt(variable.name = 'trait') %>% 
  group_by(trait) %>% 
  summarise_each(funs(min(.,na.rm = T), max(., na.rm = T), 
                      mean(.,na.rm = T), sd(.,na.rm = T))) %>% 
  left_join(PFT %>% 
              select(-Sp, -SpCode, -CE, -SHA, -LTD) %>% 
              melt(id.vars = 'Tree', 
                   variable.name = 'trait', 
                   value.name = 'Intra-individuals') %>% 
              group_by(Tree, trait) %>% 
              summarise_each(funs(sd(., na.rm = T)/mean(., na.rm = T))) %>% 
              ungroup() %>% 
              select(-Tree) %>% 
              group_by(trait) %>% 
              summarise_each(funs(mean(., na.rm = T)))) %>% 
  left_join(PFT %>% 
              group_by(Tree, Sp, SpCode, CE) %>% 
              summarise_each(funs(mean)) %>% 
              ungroup() %>% 
              select(-Tree, -SpCode, -CE, -SHA, -LTD) %>% 
              melt(id.vars = 'Sp', 
                   variable.name = 'trait', value.name = 'Intra-species') %>% 
              group_by(Sp, trait) %>% 
              summarise_each(funs(sd(., na.rm = T)/mean(., na.rm = T))) %>% 
              ungroup() %>% 
              select(-Sp) %>% 
              group_by(trait) %>% 
              summarise_each(funs(mean(., na.rm = T)))) %>% 
  left_join(PFT %>% 
              group_by(Tree, Sp, SpCode, CE) %>% 
              summarise_each(funs(mean)) %>% 
              ungroup() %>% 
              select(-Tree, -CE) %>% 
              group_by(Sp, SpCode) %>% 
              summarise_each(funs(mean)) %>% 
              ungroup() %>% 
              select(-Sp, -SpCode, -SHA, -LTD) %>% 
              melt(variable.name = 'trait', value.name = 'Inter-species') %>% 
              group_by(trait) %>% 
              summarise_each(funs(sd(., na.rm = T)/mean(., na.rm = T)))) %>% 
  kable(digits = 2, caption = 'Intra-individual, intra-specific and inter-specific component of trait variation. The overall range, mean and standard deviation are provided for each trait. The remaining columns represent the coefficient of variation of trait values among leaves per individuals (intra-individual), among trees per species (intra-specific), and among trees of different species. See table \\@ref(tab:Traits) for abbreviation.')
```

## Principal component analysis

We then performed a principal component analysis (PCA) of the mean value of traits per species to identify main dimensions of ecological strategies along which traits can covary among guilds (see figure \@ref(fig:PCA)).

The first axis of the principal component analysis (PCA) of mean species trait values was basically related to wood density and structural leaf trait variations (LT, LA, LDMC), thus opposing species with thick, big leaves and lightwood to species with dense leaves and hardwood. The second axis mostly opposed SLA to LDMC, and to a less extent to wood density. However, wood density was orthogonal to SLA in the plan 1-2 of the PCA indicating independence between those two traits.

```{r PCA,  fig.cap='Principal Component Analysis (PCA) of species mean trait values. First axis, in red, is named wood economic spectrum (WES) ; whereas second axis, in green, is named leaf economic spectrum (LES). See table \\@ref(tab:Traits) for abbreviation.'}
PFT <- PFT %>% 
  mutate(LA = log(LA)) %>% 
  mutate(SLA = log(SLA)) %>% 
  group_by(Tree, Sp, SpCode, CE) %>% 
  summarise_each(funs(mean(., na.rm = T))) %>% 
  ungroup() %>% 
  group_by(Sp, SpCode) %>% 
  summarise_each(funs(mean(., na.rm = T))) %>% 
  ungroup() %>% 
  select(-Tree, -Sp, -CE, -LTD, -SHA)
row.names(PFT) <- PFT$SpCode

PFT %>% 
  princomp(~ LA + WD + LT + LDMC + SLA, data = ., cor = T) %>% 
  autoplot(colour = 'grey', loadings.label.size = 6,
           loadings.label.colour = 'black',
           loadings = T, loadings.label = T, loadings.colour = 'black',
           loadings.label.vjust = 1.2) +
  coord_equal() +
  geom_hline(aes(yintercept = 0, linetype = 'Wood'), 
             col = 'red') +
  geom_vline(aes(xintercept = 0, linetype = 'Leaf'), 
             col = 'green') +
  xlab('Axe 1 − 33.66 %') + ylab('Axe 2 − 29.07 %') +
  scale_linetype_manual(name = "Economics\nSpectrum", values = c(2, 2), 
                        guide = guide_legend(override.aes = 
                                            list(color = c("red", "green")))) +
  theme(legend.position = c(1, 1), 
       legend.justification = c(1, 1))
```

## Hypervolumes

```{r 4 env-com}
# LES and WES
PFT <- PFT %>% 
  princomp(~ LA + WD + LT + LDMC + SLA, data = ., cor = T) %>% 
  .$scores %>% 
  data.frame() %>% 
  select(Comp.1, Comp.2) %>% 
  rename(WES = Comp.1) %>% 
  rename(LES = Comp.2) %>% 
  mutate(SpCode = row.names(.)) %>% 
  left_join(PFT)
# library(raster)
# Env <- genEnv()
# Trees <- genTrees()
# Species <- genSpecies()
# Trees$ID <- row.names(Trees)
# Trees <- merge(Trees, PFT_sp)
# row.names(Trees) <- Trees$ID
# Trees <- Trees[-which(names(Trees) == 'ID')]
# com <- quadrats(cs = c(30,30))
# XY <- Trees[c('x', 'y')]
# coordinates(XY) <- ~ x + y
# proj4string(XY) <- crs(com)
# Trees$com <- (XY %over% com)[,1]
# com@data$Elevation <- extract(Env$DEM, as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
# Deriv <- DEMderiv(raster(com, 'Elevation'), c('slope', 'curvature', 'plancurvature', 'profcurvature', 'cosaspect'), path = '/usr/share/applications')
# names(Deriv)[5] <- 'SW'
# com@data <- cbind(com@data, extract(Deriv, as(com, "SpatialPolygons"), df = T, fun = mean)[-1])
# com@data$Wetness <- extract(DEMderiv(Env$DEM, 'wetness'), as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
# com@data$Canopy <- extract(Env$Canopy, as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
# BA <- aggregate(Trees$Girth, list(Trees$com), function(x){sum(pi*(x/(2*pi))^2, na.rm = T)})
# com@data$BA <- BA$x[match(com@data$id, BA$Group.1)]
# pca.env <- princomp(~ Elevation + Slope + Curvature + PlanCurvature + ProfileCurvature + Wetness + SW, data = com@data, cor = T)
# R <- com@data[c('Slope', 'Curvature', 'Wetness', 'SW', 'Canopy', 'BA')]
# row.names(R) <- com@data$id
# L <- data.frame(tapply(rep(1, length(Trees[,1])), list(Trees$com, Trees$SpCode), sum))
# L[is.na(L)] <- 0
# Q <- PFT_sp[c('LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT')]
# row.names(Q) <- PFT_sp$SpCode
# sel <- which(Species$Strata[match(PFT_sp$SpCode, Species$SpCode)] == 3)
# Q$strata <- 'C' ; Q$strata[sel] <- 'U'
# sel <- intersect(row.names(Q), names(L))
# Q <- Q[sel,]
# Q$SpCode <- row.names(Q)
# L <- L[sel]
# R <- R[row.names(L),]
# R$community <- row.names(R)
# Lbin <- L ; Lbin[Lbin > 1]  <- 1
# rm(Deriv, XY, Env,  sel, BA, com, Trees, Species)
# save(R, L, Lbin, Q, pca.env, file = file.path(path, 'envcom.Rdata'))
rm(PFT, PFT_sp, trait)
load(file.path(path, 'envcom.Rdata'))
```

Finally we calculated hypervolume of functional traits for each guilds and their overlap. We also calculated 999 nul hypervolumes randomizing species strata. Contrarily to a previous document, observed hypervolume overlap between the two guilds was not significantly lower than null expectations ($p = 0.165$, see figure \@ref(fig:hypervolume)). This could be explained by the change of formula used to calcul hypervolume overlap in the last version of the hypervolume R package (sorensen overlap changed in version 2.1). We still have a methodological question, the hypervolume is built on unnormalized traits values. Traits standrad deviation is used to sample around the species points, so there is no issu around the bandwidth. But we still can question the fact that variable with higher value variations can diminish the overlap signal.

```{r hypervolume, eval=FALSE, fig.cap='Functional hypervolume overlap of canopy and understorey species.'}
bd <- Q %>% 
  filter(!is.na(WES)) %>% 
  select(-LES, -WES, -SpCode, -strata) %>% 
  summarise_all(funs(sd)) %>% 
  unlist()
CalcOverlap <- function(traits_strata){
  hv <- lapply(traits_strata, function(strata) 
    hypervolume::hypervolume(strata[names(bd)], kde.bandwidth = bd, verbose = F))
  set <- hypervolume::hypervolume_set(hv$C, hv$U, check.memory = F, verbose = F)
  hypervolume::hypervolume_overlap_statistics(set)
}
overlap <- Q %>% 
  filter(!is.na(WES)) %>% 
  select(-LES, -WES, -SpCode) %>% 
  split(., .$strata) %>% 
  CalcOverlap()
# cl <- makeCluster(cores)
# clusterExport(cl, list('Q', 'CalcOverlap', 'bd'))
# n_overlap <- parSapply(cl, 1:n, function(i) {
#   library(dplyr)
#   Q %>%
#     filter(!is.na(WES)) %>%
#     select(-LES, -WES, -SpCode) %>%
#     mutate(strata = sample(strata)) %>%
#     split(., .$strata) %>%
#     CalcOverlap()
# })
# stopCluster(cl)
# save(n_overlap, file = file.path(path, 'overlap.Rdata'))
load(file.path(path, 'overlap.Rdata'))
data.frame(x = n_overlap) %>% 
  ggplot(aes(x)) +
  geom_density() +
  geom_vline(xintercept = overlap,
             col = 'red') +
  ggtitle(paste('pvalue =', 
                round((rank(c(overlap, n_overlap))/(n+1))[1], 3))) +
  xlab('Overlap null distribution')
summary(overlap$C)
CalcOverlap(overlap$C, overlap$U)
```

 Effectivelly some traits seems to show strong differentation between guilds (see figure and table \@ref(tab:hypervolume2)).
 
```{r hypervolume2, eval=FALSE}
data <- Q %>% 
  filter(!is.na(WES)) %>% 
  select(-LES, -WES, -SpCode) %>% 
  split(., .$strata)
hv <- lapply(data, function(strata) 
    hypervolume::hypervolume(strata[names(bd)], bandwidth = bd, verbose = F))
set <- hypervolume::hypervolume_set(hv$C, hv$U, check_memory = F, verbose = F)
hv <- list(C = set@HVList$Unique_1,
           U = set@HVList$Unique_2,
           Intersect = set@HVList$Intersection)
plot(hypervolume::hypervolume_join(hv$C, hv$U))
hv <- list(C = data$C[
  hypervolume::hypervolume_inclusion_test(hv$C, data$C[names(bd)]),],
           U = data$U[
  hypervolume::hypervolume_inclusion_test(hv$U, data$U[names(bd)]),],
           Intersect = do.call('rbind', data)[
  hypervolume::hypervolume_inclusion_test(hv$Intersect, 
                                          do.call('rbind', data)[names(bd)]),])

kable(do.call('rbind', lapply(hv, function(x)apply(x[names(bd)], 2, mean))),
      caption = 'means of hypervolumes functional traits')
rm(hv, set, data, CalcOverlap, bd)
```


# Functional composition of guilds

We subdivided the 10-ha plot into $30*30 m^2$ quadrats leading to 110 local communities. We analyze the functionnal composition of the guilds in the 110 communities. We calculated weighted mean [GWM, where G stands for "guild"; @violle_let_2007] for each guild in each community. In the quadrat $j$, GWM of trait $t$ was the mean of trait values $t_{i}$ of species $i$ weighted by species relative abundance $p_{i}$:
$$GWM_{j} = \sum_{i=1}^{S} p_{i,j} * t_{i,j} ~ (1)$$
where $S$ is the number of species in the quadrat $j$. We also calculated the average trait values based on presence-absence values to assess the influence of less abundant and rare species on community trait composition [@cingolani_filtering_2007]. 

To test for any significant changes in functional composition among guilds, we devised a null model approach. We described further each null moels when introducing GWM or GWV results. We performed 999 randomizations of null models and we derived a two-tailed test of the proportion of guilds deviating from the null expectation, with adjusted p-values by Benjamini-Hochberg correction. Shifts in GWM or GWV values with changing environmental conditions could reflect the shift of species strategies across assemblages [@ackerly_trait-based_2007].

To characterize the patterns of deviation from the null model, we also calculated standardized effect sizes (SES) as
$$SES = \frac{(I_{obs} - I_{null})}{\sigma _{null}} (2)$$
where $I_{obs}$ was the observed metric and $I_{null}$ and $\sigma _{null}$ were the mean and standard deviation of the corresponding null distribution. The influence of environment on SES values was investigated by linear regression with biotic and abiotic factors ($SES_{trait} = Slope + Curvature + Wetness + SW + Canopy + BA$). Analyses were conducted on the five functional traits and the species scores obtained on the two first PCA axes done on the `Trait*Species` matrix .

## Guild weighted means : nul model 1

We used a null model (NM1) which randomized trait values among species in the whole plot (permuting raw in `Trait*Species` matrix) [@bernard-verdier_community_2012].

We foud back the results of previous documents (see table \@ref(tab:GWM1)). The guild weighted trait means (GWM) varied weakly but significantly along the environmental gradients for both canopy (C) and understorey (U) guilds. Functional traits of canopy and understorey tree species were both influenced by curvature, but not for the same traits, and two major differences were observed between the two guilds. The effect of south-west orientation on functional composition was observed only for canopy tree species, while the effect of canopy height affected mostly understory guild composition.

I did not detailed back specific trait results. And the question to keep or not economics spectrum in the table is opened ?

```{r GWM1}
GWM <- L %>% 
  t() %>% 
  data.frame() %>% 
  mutate(SpCode = row.names(.)) %>% 
  left_join(Q) %>% 
  select(-SpCode) %>% 
  melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
       variable.name = 'community', value.name = 'abundance') %>% 
  group_by(strata, community) %>% 
  summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance)
# nQ <- array(rep(as.matrix(Q), n),
#             c(dim(Q), n),
#             list(row.names(Q), names(Q), 1:n))
# nQ <- array(apply(nQ, 3, function(x){
#   x[,'SpCode'] <- sample(x[,'SpCode'])
#   return(x)}), c(dim(Q), n),
#   list(row.names(Q), names(Q), 1:n))
# cl <- makeCluster(cores)
# clusterExport(cl, list('L', 'nQ'))
# nGWM <- parApply(cl, nQ, 3, function(x){
#   library(dplyr)
#   library(reshape2)
#   L %>%
#     t() %>%
#     data.frame() %>%
#     mutate(SpCode = row.names(.)) %>%
#     left_join(data.frame(x)) %>%
#     select(-SpCode) %>%
#     melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
#          variable.name = 'community', value.name = 'abundance') %>%
#     group_by(strata, community) %>%
#     mutate_each(funs(as.character), -abundance) %>%
#     mutate_each(funs(as.numeric), -abundance) %>%
#     summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance)
# })
# stopCluster(cl)
# nGWM <- array(unlist(lapply(nGWM, function(x) as.matrix(x[3:9]))),
#               c(dim(GWM[3:9]), n),
#               list(row.names(GWM), names(GWM[3:9]), 1:n))
# GWM_ses <- GWM
# GWM_ses[3:9] <- (GWM[3:9] - apply(nGWM, 1:2, mean, na.rm = T))/apply(nGWM, 1:2, sd, na.rm = T)
# rm(cl, nQ, nGWM)
# save(GWM_ses, file = file.path(path, 'GWM1_ses.Rdata'))
load(file.path(path, 'GWM1_ses.Rdata'))
GWM_ses %>% 
  melt(id.vars = c('strata', 'community')) %>% 
  rename(trait = variable) %>% 
  rename(SES = value) %>% 
  left_join(R) %>%
  select(-community) %>% 
  group_by(strata, trait) %>% 
  do(tidy(step(lm(SES ~ Slope + Curvature + Wetness + SW + Canopy + BA, .), 
          direction = 'both', trace = 0))) %>% 
  group_by(strata, trait, term) %>%
  transmute(value = paste(format(estimate, scientific = T, digits = 2, trim = T), 
                          stars(p.value, ns = '   '))) %>% 
  dcast(strata + trait ~ term) %>% 
  select(strata, trait, Slope, Curvature, Wetness, SW, Canopy, BA) %>% 
  mutate_each(funs(replace(., is.na(.), ' '))) %>% 
  bold() %>% 
  kable(caption = 'Linear models of the standardized effect size (SES) for each trait of GWMs, for canopy (C) and understorey (U) guilds, in abundance. We performed stepwise selection of the predictors including slope, curvature, wetness southwesterness (SW), canopy height (Canopy) and basal area (BA), and only the selected predictors are shown. See table \\@ref(tab:Traits) for abbreviations. Bold and number of asterisk indicates the significance threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001).')
```

```{r WD, fig.cap='Exemple of standard effect size (SES) of wood density  (WD) for canopy (C) tree species. Each subplot show  standard effect size (SES) of wood density (WD) for canopy (C) tree species along one environmental variable gradient. Continuous line represents a null SES, whereas dashed line represents limits of the confidence interval above which SES are considered as significant. See table \\@ref(tab:Traits) for abbreviation.'}
GWM_ses %>% 
  select(strata, WD, community) %>% 
  left_join(R) %>% 
  filter(strata == 'C') %>% 
  ungroup() %>% 
  select(-strata, -community) %>% 
  melt(id.vars = 'WD') %>% 
  ggplot(aes(value, WD)) +
  geom_point() +
  facet_wrap(~ variable, scales = "free") +
  geom_hline(yintercept = c(0.95, -0.95), linetype = 'dashed') +
  geom_hline(yintercept = 0) +
  xlab('Environmental gradient') +
  ylab('Standard effect size of wood density')
```

## Guild weighted means : nul model 3

We used a null model (NM3) which randomized species among guilds in the whole plot (see table \@ref(tab:GWM3)).

We found that **curvature** was responsible for the guilds differenciation for most of the traits. Increased curvature resulted in denser lwood and leaves with high SLA in canopy, against lighter wood, low SLA, but bigger and thicker leaves in understorey. Some curvature results were congruent with **Wetness** variable. **South-West** orientation diminished the leaf area while increasing leaf density for canopy tree species. Finally, **Canopy** height and **basal area** affected in opposite ways SLA. Increased canopy height and decreased basal area resulted in lower SLA in canopy and increased SLA in understorey.

```{r GWM3}
GWM <- L %>% 
  t() %>% 
  data.frame() %>% 
  mutate(SpCode = row.names(.)) %>% 
  left_join(Q) %>% 
  select(-SpCode) %>% 
  melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
       variable.name = 'community', value.name = 'abundance') %>% 
  group_by(strata, community) %>% 
  summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance)
# nQ <- array(rep(as.matrix(Q), n),
#             c(dim(Q), n),
#             list(row.names(Q), names(Q), 1:n))
# nQ <- array(apply(nQ, 3, function(x){
#   x[,'strata'] <- sample(x[,'strata'])
#   return(x)}), c(dim(Q), n),
#   list(row.names(Q), names(Q), 1:n))
# cl <- makeCluster(cores)
# clusterExport(cl, list('L', 'nQ'))
# nGWM <- parApply(cl, nQ, 3, function(x){
#   library(dplyr)
#   library(reshape2)
#   L %>%
#     t() %>%
#     data.frame() %>%
#     mutate(SpCode = row.names(.)) %>%
#     left_join(data.frame(x)) %>%
#     select(-SpCode) %>%
#     melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
#          variable.name = 'community', value.name = 'abundance') %>%
#     group_by(strata, community) %>%
#     mutate_each(funs(as.character), -abundance) %>%
#     mutate_each(funs(as.numeric), -abundance) %>%
#     summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance)
# })
# stopCluster(cl)
# nGWM <- array(unlist(lapply(nGWM, function(x) as.matrix(x[3:9]))),
#               c(dim(GWM[3:9]), n),
#               list(row.names(GWM), names(GWM[3:9]), 1:n))
# GWM_ses <- GWM
# GWM_ses[3:9] <- (GWM[3:9] - apply(nGWM, 1:2, mean, na.rm = T))/apply(nGWM, 1:2, sd, na.rm = T)
# rm(cl, nQ, nGWM)
# save(GWM_ses, file = file.path(path, 'GWM3_ses.Rdata'))
load(file.path(path, 'GWM3_ses.Rdata'))
GWM_ses %>% 
  melt(id.vars = c('strata', 'community')) %>% 
  rename(trait = variable) %>% 
  rename(SES = value) %>% 
  left_join(R) %>%
  select(-community) %>% 
  group_by(strata, trait) %>% 
  do(tidy(step(lm(SES ~ Slope + Curvature + Wetness + SW + Canopy + BA, .), 
          direction = 'both', trace = 0))) %>% 
  group_by(strata, trait, term) %>%
  transmute(value = paste(format(estimate, scientific = T, digits = 2, trim = T), 
                          stars(p.value, ns = '   '))) %>% 
  dcast(strata + trait ~ term) %>% 
  select(strata, trait, Slope, Curvature, Wetness, SW, Canopy, BA) %>% 
  mutate_each(funs(replace(., is.na(.), ' '))) %>% 
  bold() %>% 
  kable(caption = 'Linear models of the standardized effect size (SES) for each trait of GWMs, for canopy (C) and understorey (U) guilds, in abundance. We performed stepwise selection of the predictors including slope, curvature, wetness southwesterness (SW), canopy height (Canopy) and basal area (BA), and only the selected predictors are shown. See table \\@ref(tab:Traits) for abbreviations. Bold and number of asterisk indicates the significance threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001).')
```

## Guild weighted variances : nul model 2

The second model (NM2) randomized abundances among species within each guild but kept the observed list of species and trait values unchanged inside guilds [@bernard-verdier_community_2012].

We found significant relationships between the standardized effect size (SES) of GWVs and the environmental predictors (see table \@ref(tab:GWV3)). **Wetness** decreased variance of wood density in canopy and all traits in understorey. **Curvature** increased LDMC variance in canopy. **Sout-West** orientation results in decreased variance of density of wood and leaf in understorey. Finally, **Canopy** hieght diminished variance of leaf are and density in canopy whereas **basal aea** increased variance of SLA in both strata and increased leaf area variance in canopy. 

```{r GWV3}
GWV <- L %>% 
  t() %>% 
  data.frame() %>% 
  filter(sum(.) > 2) %>% 
  mutate(SpCode = row.names(.)) %>% 
  left_join(Q) %>% 
  select(-SpCode) %>% 
  melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
       variable.name = 'community', value.name = 'abundance') %>% 
  melt(id.vars = c('strata', 'community', 'abundance'),
       variable.name = 'trait', value.name = 'trait_value') %>% 
  left_join(melt(GWM, id.vars = c('strata', 'community'),
                 variable.name = 'trait', value.name = 'GWM')) %>% 
  group_by(strata, community, trait) %>% 
  mutate(GWV = (trait_value - GWM)^2) %>% 
  select(-trait_value, -GWM) %>% 
  summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance) %>% 
  dcast(strata + community ~ trait)
# nL <- array(replicate(n, t(apply(L, 1, function(x){
#   x[x != 0] <- sample(x[which(x != 0)]) ; return(x)}))),
#   c(dim(L), n),
#   list(row.names(L), names(L), 1:n))
# cl <- makeCluster(cores)
# clusterExport(cl, list('nL', 'Q', 'GWM'))
# nGWV <- parApply(cl, nL, 3, function(x){
#   library(dplyr)
#   library(reshape2)
#   x %>%
#     t() %>%
#     data.frame() %>%
#     filter(sum(.) > 2) %>%
#     mutate(SpCode = row.names(.)) %>%
#     left_join(Q) %>%
#     select(-SpCode) %>%
#     melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
#          variable.name = 'community', value.name = 'abundance') %>%
#     melt(id.vars = c('strata', 'community', 'abundance'),
#          variable.name = 'trait', value.name = 'trait_value') %>%
#     left_join(melt(GWM, id.vars = c('strata', 'community'),
#                    variable.name = 'trait', value.name = 'GWM')) %>%
#     group_by(strata, community, trait) %>%
#     mutate(GWV = (trait_value - GWM)^2) %>%
#     select(-trait_value, -GWM) %>%
#     summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance) %>%
#     dcast(strata + community ~ trait)
# })
# stopCluster(cl)
# nGWV <- array(unlist(lapply(nGWV, function(x) as.matrix(x[3:9]))),
#               c(dim(GWV[3:9]), n),
#               list(row.names(GWV), names(GWV[3:9]), 1:n))
# GWV_ses <- GWV
# GWV_ses[3:9] <- (GWV[3:9] - apply(nGWV, 1:2, mean, na.rm = T))/apply(nGWV, 1:2, sd, na.rm = T)
# rm(cl, nL, nGWV)
# save(GWV_ses, file = file.path(path, 'GWV_ses.Rdata'))
load(file.path(path, 'GWV_ses.Rdata'))
GWV_ses %>% 
  melt(id.vars = c('strata', 'community')) %>% 
  rename(trait = variable) %>% 
  rename(SES = value) %>% 
  left_join(R) %>%
  select(-community) %>% 
  group_by(strata, trait) %>% 
  do(tidy(step(lm(SES ~ Slope + Curvature + Wetness + SW + Canopy + BA, .), 
          direction = 'both', trace = 0))) %>% 
  group_by(strata, trait, term) %>%
  transmute(value = paste(format(estimate, scientific = T, digits = 2, trim = T), 
                          stars(p.value, ns = '   '))) %>% 
  dcast(strata + trait ~ term) %>% 
  select(strata, trait, Slope, Curvature, Wetness, SW, Canopy, BA) %>% 
  mutate_each(funs(replace(., is.na(.), ' '))) %>% 
  bold() %>% 
  kable(caption = 'Linear models of the standardized effect sizes (SES) of GWV and CVNND, for canopy (C) and understorey (U) guilds. We performed stepwise selection of the predictors including slope, curvature, wetness southwesterness (SW), canopy height (Canopy) and basal area (BA), and only the selected predictors are shown. See table \\@ref(tab:Traits) for abbreviations. Bold and  number of asterisk indicates the significance threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001).')
```

# Supplementary materials

## Principal component analysis of environment

No comment yet.

```{r PCAenv, fig.cap='Principal component analysis (PCA) performed on topgraphical variables. SW stand for southwesterness.'}
pca.env %>% 
  autoplot(colour = 'grey', loadings.label.size = 6,
           loadings.label.colour = 'black',
           loadings = T, loadings.label = T, 
           loadings.colour = 'black',
           loadings.label.vjust = 2) +
  coord_equal() +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  geom_vline(xintercept = 0, linetype = 'dashed') +
  xlab('Axe 1 − 42.52 %') + ylab('Axe 2 − 23.44 %')
```

# References {-}

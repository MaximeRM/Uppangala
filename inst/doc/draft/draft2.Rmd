---
title: Decoupled wood and leaf strategies among canopy and understorey tree in a low-elevation rainforest of India
author: "Sylvain Schmitt sylvain.schmitt@agroparistech.fr"
date: '`r Sys.Date()`'
csl: mee.csl
bibliography: refs.bib
knit: "bookdown::render_book"
output:
  bookdown::gitbook:
    split_by: none
---

```{r config, message=FALSE, warning=FALSE, include=FALSE}
rm(list = ls()); invisible(gc())
library(knitr)
library(parallel)
library(Uppangala)
library(broom)
library(vegan)
library(dplyr)
library(reshape2)
library(ggplot2)
library(ggfortify)
cores <- detectCores() - 1
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 8, fig.width = 8,
  cache = T, cache.lazy = F)
cv <- function(x, na.rm = T)
  sd(x, na.rm = na.rm)/mean(x, na.rm = na.rm)
path <- '~/Documents/IFP/Uppangala/inst/doc/draft_save/'
n = 9 # Random repetitions
```

# Introduction {-}

# Data

```{r Traits}
PFT <- genPFT()
kable(data.frame(
  Trait = c('Leaf thickness', 'Leaf area', 'Leaf dry matter content', 'Specific leaf area', 'Wood density'),
  Abbreviation = c('LT', 'LA', 'LDMC', 'SLA', 'WD'),
  Unit = c('$\\mu m$', '$mm^2$', '$mg.g^-1$', '$m^2.kg^-1$', '$g.cm^-3$'),
  Strategy = c('Leaf defense and investment',
        'Leaf resource capture vs.investment',
        'Leaf defense and investment',
        'Leaf resource acquisiton vs. defense',
        'Stem transport, structure and defense')
), caption = 'Functional traits measured. Traits with their abbreviation, standard unit, and associated species strategy for functioning, survival and reproduction [@baraloto_decoupled_2010].')
```

# Trait variation and covariation

## Coefficients of variation

```{r CV}
PFT %>% 
  select(-Tree, -Sp, -SpCode, -CE, -SHA, -LTD) %>% 
  melt(variable.name = 'trait') %>% 
  group_by(trait) %>% 
  summarise_each(funs(min(.,na.rm = T), max(., na.rm = T), 
                      mean(.,na.rm = T), sd(.,na.rm = T))) %>% 
  left_join(PFT %>% 
              select(-Sp, -SpCode, -CE, -SHA, -LTD) %>% 
              melt(id.vars = 'Tree', 
                   variable.name = 'trait', 
                   value.name = 'Intra-individuals') %>% 
              group_by(Tree, trait) %>% 
              summarise_each(funs(sd(., na.rm = T)/mean(., na.rm = T))) %>% 
              ungroup() %>% 
              select(-Tree) %>% 
              group_by(trait) %>% 
              summarise_each(funs(mean(., na.rm = T)))) %>% 
  left_join(PFT %>% 
              group_by(Tree, Sp, SpCode, CE) %>% 
              summarise_each(funs(mean)) %>% 
              ungroup() %>% 
              select(-Tree, -SpCode, -CE, -SHA, -LTD) %>% 
              melt(id.vars = 'Sp', 
                   variable.name = 'trait', value.name = 'Intra-species') %>% 
              group_by(Sp, trait) %>% 
              summarise_each(funs(sd(., na.rm = T)/mean(., na.rm = T))) %>% 
              ungroup() %>% 
              select(-Sp) %>% 
              group_by(trait) %>% 
              summarise_each(funs(mean(., na.rm = T)))) %>% 
  left_join(PFT %>% 
              group_by(Tree, Sp, SpCode, CE) %>% 
              summarise_each(funs(mean)) %>% 
              ungroup() %>% 
              select(-Tree, -CE) %>% 
              group_by(Sp, SpCode) %>% 
              summarise_each(funs(mean)) %>% 
              ungroup() %>% 
              select(-Sp, -SpCode, -SHA, -LTD) %>% 
              melt(variable.name = 'trait', value.name = 'Inter-species') %>% 
              group_by(trait) %>% 
              summarise_each(funs(sd(., na.rm = T)/mean(., na.rm = T)))) %>% 
  kable(digits = 2, caption = 'Intra-individual, intra-specific and inter-specific component of trait variation. The overall range, mean and standard deviation are provided for each trait. The remaining columns represent the coefficient of variation of trait values among leaves per individuals (intra-individual), among trees per species (intra-specific), and among trees of different species. See table \\@ref(tab:Traits) for abbreviation.')
```

## Principal component analysis

```{r PCA,  fig.cap='Principal Component Analysis (PCA) of species mean trait values. First axis, in red, is named wood economic spectrum (WES) ; whereas second axis, in green, is named leaf economic spectrum (LES). See table \\@ref(tab:Traits) for abbreviation.'}
PFT <- PFT %>% 
  mutate(LA = log(LA)) %>% 
  mutate(SLA = log(SLA)) %>% 
  group_by(Tree, Sp, SpCode, CE) %>% 
  summarise_each(funs(mean(., na.rm = T))) %>% 
  ungroup() %>% 
  group_by(Sp, SpCode) %>% 
  summarise_each(funs(mean(., na.rm = T))) %>% 
  ungroup() %>% 
  select(-Tree, -Sp, -CE, -LTD, -SHA)
row.names(PFT) <- PFT$SpCode

PFT %>% 
  princomp(~ LA + WD + LT + LDMC + SLA, data = ., cor = T) %>% 
  autoplot(colour = 'grey', loadings.label.size = 6,
           loadings.label.colour = 'black',
           loadings = T, loadings.label = T, loadings.colour = 'black',
           loadings.label.vjust = 1.2) +
  coord_equal() +
  geom_hline(aes(yintercept = 0, linetype = 'Wood'), 
             col = 'red') +
  geom_vline(aes(xintercept = 0, linetype = 'Leaf'), 
             col = 'green') +
  xlab('Axe 1 − 33.66 %') + ylab('Axe 2 − 29.07 %') +
  scale_linetype_manual(name = "Economics\nSpectrum", values = c(2, 2), 
                        guide = guide_legend(override.aes = 
                                            list(color = c("red", "green")))) +
  theme(legend.position = c(1, 1), 
       legend.justification = c(1, 1))
```

## Hypervolumes

```{r 4 env-com}
# LES and WES
PFT <- PFT %>% 
  princomp(~ LA + WD + LT + LDMC + SLA, data = ., cor = T) %>% 
  .$scores %>% 
  data.frame() %>% 
  select(Comp.1, Comp.2) %>% 
  rename(WES = Comp.1) %>% 
  rename(LES = Comp.2) %>% 
  mutate(SpCode = row.names(.)) %>% 
  left_join(PFT)
# library(raster)
# Env <- genEnv()
# Trees <- genTrees()
# Species <- genSpecies()
# Trees$ID <- row.names(Trees)
# Trees <- merge(Trees, PFT_sp)
# row.names(Trees) <- Trees$ID
# Trees <- Trees[-which(names(Trees) == 'ID')]
# com <- quadrats(cs = c(30,30))
# XY <- Trees[c('x', 'y')]
# coordinates(XY) <- ~ x + y
# proj4string(XY) <- crs(com)
# Trees$com <- (XY %over% com)[,1]
# com@data$Elevation <- extract(Env$DEM, as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
# Deriv <- DEMderiv(raster(com, 'Elevation'), c('slope', 'curvature', 'plancurvature', 'profcurvature', 'cosaspect'), path = '/usr/share/applications')
# names(Deriv)[5] <- 'SW'
# com@data <- cbind(com@data, extract(Deriv, as(com, "SpatialPolygons"), df = T, fun = mean)[-1])
# com@data$Wetness <- extract(DEMderiv(Env$DEM, 'wetness'), as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
# com@data$Canopy <- extract(Env$Canopy, as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
# BA <- aggregate(Trees$Girth, list(Trees$com), function(x){sum(pi*(x/(2*pi))^2, na.rm = T)})
# com@data$BA <- BA$x[match(com@data$id, BA$Group.1)]
# pca.env <- princomp(~ Elevation + Slope + Curvature + PlanCurvature + ProfileCurvature + Wetness + SW, data = com@data, cor = T)
# R <- com@data[c('Slope', 'Curvature', 'Wetness', 'SW', 'Canopy', 'BA')]
# row.names(R) <- com@data$id
# L <- data.frame(tapply(rep(1, length(Trees[,1])), list(Trees$com, Trees$SpCode), sum))
# L[is.na(L)] <- 0
# Q <- PFT_sp[c('LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT')]
# row.names(Q) <- PFT_sp$SpCode
# sel <- which(Species$Strata[match(PFT_sp$SpCode, Species$SpCode)] == 3)
# Q$strata <- 'C' ; Q$strata[sel] <- 'U'
# sel <- intersect(row.names(Q), names(L))
# Q <- Q[sel,]
# Q$SpCode <- row.names(Q)
# L <- L[sel]
# R <- R[row.names(L),]
# R$community <- row.names(R)
# Lbin <- L ; Lbin[Lbin > 1]  <- 1
# rm(Deriv, XY, Env,  sel, BA, com, Trees, Species)
# save(R, L, Lbin, Q, pca.env, file = file.path(path, 'envcom.Rdata'))
rm(PFT, PFT_sp, trait)
load(file.path(path, 'envcom.Rdata'))
```

```{r hypervolume, fig.cap='Functional hypervolume overlap of canopy and understorey species.'}
bd <- Q %>% 
  filter(!is.na(WES)) %>% 
  select(-LES, -WES, -SpCode, -strata) %>% 
  summarise_all(funs(sd)) %>% 
  unlist()
CalcOverlap <- function(traits_strata){
  hv <- lapply(traits_strata, function(strata) 
    hypervolume::hypervolume(strata[names(bd)], bandwidth = bd, verbose = F))
  set <- hypervolume::hypervolume_set(hv$C, hv$U, check_memory = F, verbose = F)
  hypervolume::hypervolume_sorensen_overlap(set)
}
overlap <- Q %>% 
  filter(!is.na(WES)) %>% 
  select(-LES, -WES, -SpCode) %>% 
  split(., .$strata) %>% 
  CalcOverlap()
# cl <- makeCluster(cores)
# clusterExport(cl, list('Q', 'CalcOverlap', 'bd'))
# n_overlap <- parSapply(cl, 1:n, function(i) {
#   library(dplyr)
#   Q %>% 
#     filter(!is.na(WES)) %>% 
#     select(-LES, -WES, -SpCode) %>% 
#     mutate(strata = sample(strata)) %>% 
#     split(., .$strata) %>% 
#     CalcOverlap()
# })
# stopCluster(cl)
# save(n_overlap, file = file.path(path, 'overlap.Rdata'))
load(file.path(path, 'overlap.Rdata'))
data.frame(x = n_overlap) %>% 
  ggplot(aes(x)) +
  geom_density() +
  geom_vline(xintercept = overlap,
             col = 'red') +
  ggtitle(paste('pvalue =', 
                round((rank(c(overlap, n_overlap))/(n+1))[1], 2))) +
  xlab('Overlap null distribution')
```

```{r hypervolume2}
data <- Q %>% 
  filter(!is.na(WES)) %>% 
  select(-LES, -WES, -SpCode) %>% 
  split(., .$strata)
hv <- lapply(data, function(strata) 
    hypervolume::hypervolume(strata[names(bd)], bandwidth = bd, verbose = F))
set <- hypervolume::hypervolume_set(hv$C, hv$U, check_memory = F, verbose = F)
hv <- list(C = set@HVList$Unique_1,
           U = set@HVList$Unique_2,
           Intersect = set@HVList$Intersection)
plot(hypervolume::hypervolume_join(hv$C, hv$U))
hv <- list(C = data$C[
  hypervolume::hypervolume_inclusion_test(hv$C, data$C[names(bd)]),],
           U = data$U[
  hypervolume::hypervolume_inclusion_test(hv$U, data$U[names(bd)]),],
           Intersect = do.call('rbind', data)[
  hypervolume::hypervolume_inclusion_test(hv$Intersect, 
                                          do.call('rbind', data)[names(bd)]),])

kable(do.call('rbind', lapply(hv, function(x)apply(x[names(bd)], 2, mean))),
      caption = 'means of hypervolumes functional traits')
rm(hv, set, data, CalcOverlap, bd)
```


# Functional composition of guilds

## Guild weighted means : nul model 1

```{r GWM1}
GWM <- L %>% 
  t() %>% 
  data.frame() %>% 
  mutate(SpCode = row.names(.)) %>% 
  left_join(Q) %>% 
  select(-SpCode) %>% 
  melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
       variable.name = 'community', value.name = 'abundance') %>% 
  group_by(strata, community) %>% 
  summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance)
# nQ <- array(rep(as.matrix(Q), n),
#             c(dim(Q), n),
#             list(row.names(Q), names(Q), 1:n))
# nQ <- array(apply(nQ, 3, function(x){
#   x[,'SpCode'] <- sample(x[,'SpCode'])
#   return(x)}), c(dim(Q), n),
#   list(row.names(Q), names(Q), 1:n))
# cl <- makeCluster(cores)
# clusterExport(cl, list('L', 'nQ'))
# nGWM <- parApply(cl, nQ, 3, function(x){
#   library(dplyr)
#   library(reshape2)
#   L %>%
#     t() %>%
#     data.frame() %>%
#     mutate(SpCode = row.names(.)) %>%
#     left_join(data.frame(x)) %>%
#     select(-SpCode) %>%
#     melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
#          variable.name = 'community', value.name = 'abundance') %>%
#     group_by(strata, community) %>%
#     mutate_each(funs(as.character), -abundance) %>%
#     mutate_each(funs(as.numeric), -abundance) %>%
#     summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance)
# })
# stopCluster(cl)
# nGWM <- array(unlist(lapply(nGWM, function(x) as.matrix(x[3:9]))),
#               c(dim(GWM[3:9]), n),
#               list(row.names(GWM), names(GWM[3:9]), 1:n))
# GWM_ses <- GWM
# GWM_ses[3:9] <- (GWM[3:9] - apply(nGWM, 1:2, mean, na.rm = T))/apply(nGWM, 1:2, sd, na.rm = T)
# rm(cl, nQ, nGWM)
# save(GWM_ses, file = file.path(path, 'GWM1_ses.Rdata'))
load(file.path(path, 'GWM1_ses.Rdata'))
GWM_ses %>% 
  melt(id.vars = c('strata', 'community')) %>% 
  rename(trait = variable) %>% 
  rename(SES = value) %>% 
  left_join(R) %>%
  select(-community) %>% 
  group_by(strata, trait) %>% 
  do(tidy(step(lm(SES ~ Slope + Curvature + Wetness + SW + Canopy + BA, .), 
          direction = 'both', trace = 0))) %>% 
  group_by(strata, trait, term) %>%
  transmute(value = paste(format(estimate, scientific = T, digits = 2, trim = T), 
                          stars(p.value, ns = '   '))) %>% 
  dcast(strata + trait ~ term) %>% 
  select(strata, trait, Slope, Curvature, Wetness, SW, Canopy, BA) %>% 
  mutate_each(funs(replace(., is.na(.), ' '))) %>% 
  bold() %>% 
  kable(caption = 'Linear models of the standardized effect size (SES) for each trait of GWMs, for canopy (C) and understorey (U) guilds, in abundance. We performed stepwise selection of the predictors including slope, curvature, wetness southwesterness (SW), canopy height (Canopy) and basal area (BA), and only the selected predictors are shown. See table \\@ref(tab:Traits) for abbreviations. Bold and number of asterisk indicates the significance threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001).')
```

```{r WD, fig.cap='Exemple of standard effect size (SES) of wood density  (WD) for canopy (C) tree species. Each subplot show  standard effect size (SES) of wood density (WD) for canopy (C) tree species along one environmental variable gradient. Continuous line represents a null SES, whereas dashed line represents limits of the confidence interval above which SES are considered as significant. See table \\@ref(tab:Traits) for abbreviation.'}
GWM_ses %>% 
  select(strata, WD, community) %>% 
  left_join(R) %>% 
  filter(strata == 'C') %>% 
  ungroup() %>% 
  select(-strata, -community) %>% 
  melt(id.vars = 'WD') %>% 
  ggplot(aes(value, WD)) +
  geom_point() +
  facet_wrap(~ variable, scales = "free") +
  geom_hline(yintercept = c(0.95, -0.95), linetype = 'dashed') +
  geom_hline(yintercept = 0) +
  xlab('Environmental gradient') +
  ylab('Standard effect size of wood density')
```

## Guild weighted means : nul model 3

```{r GWM3}
GWM <- L %>% 
  t() %>% 
  data.frame() %>% 
  mutate(SpCode = row.names(.)) %>% 
  left_join(Q) %>% 
  select(-SpCode) %>% 
  melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
       variable.name = 'community', value.name = 'abundance') %>% 
  group_by(strata, community) %>% 
  summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance)
# nQ <- array(rep(as.matrix(Q), n),
#             c(dim(Q), n),
#             list(row.names(Q), names(Q), 1:n))
# nQ <- array(apply(nQ, 3, function(x){
#   x[,'strata'] <- sample(x[,'strata'])
#   return(x)}), c(dim(Q), n),
#   list(row.names(Q), names(Q), 1:n))
# cl <- makeCluster(cores)
# clusterExport(cl, list('L', 'nQ'))
# nGWM <- parApply(cl, nQ, 3, function(x){
#   library(dplyr)
#   library(reshape2)
#   L %>%
#     t() %>%
#     data.frame() %>%
#     mutate(SpCode = row.names(.)) %>%
#     left_join(data.frame(x)) %>%
#     select(-SpCode) %>%
#     melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
#          variable.name = 'community', value.name = 'abundance') %>%
#     group_by(strata, community) %>%
#     mutate_each(funs(as.character), -abundance) %>%
#     mutate_each(funs(as.numeric), -abundance) %>%
#     summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance)
# })
# stopCluster(cl)
# nGWM <- array(unlist(lapply(nGWM, function(x) as.matrix(x[3:9]))),
#               c(dim(GWM[3:9]), n),
#               list(row.names(GWM), names(GWM[3:9]), 1:n))
# GWM_ses <- GWM
# GWM_ses[3:9] <- (GWM[3:9] - apply(nGWM, 1:2, mean, na.rm = T))/apply(nGWM, 1:2, sd, na.rm = T)
# rm(cl, nQ, nGWM)
# save(GWM_ses, file = file.path(path, 'GWM3_ses.Rdata'))
load(file.path(path, 'GWM3_ses.Rdata'))
GWM_ses %>% 
  melt(id.vars = c('strata', 'community')) %>% 
  rename(trait = variable) %>% 
  rename(SES = value) %>% 
  left_join(R) %>%
  select(-community) %>% 
  group_by(strata, trait) %>% 
  do(tidy(step(lm(SES ~ Slope + Curvature + Wetness + SW + Canopy + BA, .), 
          direction = 'both', trace = 0))) %>% 
  group_by(strata, trait, term) %>%
  transmute(value = paste(format(estimate, scientific = T, digits = 2, trim = T), 
                          stars(p.value, ns = '   '))) %>% 
  dcast(strata + trait ~ term) %>% 
  select(strata, trait, Slope, Curvature, Wetness, SW, Canopy, BA) %>% 
  mutate_each(funs(replace(., is.na(.), ' '))) %>% 
  bold() %>% 
  kable(caption = 'Linear models of the standardized effect size (SES) for each trait of GWMs, for canopy (C) and understorey (U) guilds, in abundance. We performed stepwise selection of the predictors including slope, curvature, wetness southwesterness (SW), canopy height (Canopy) and basal area (BA), and only the selected predictors are shown. See table \\@ref(tab:Traits) for abbreviations. Bold and number of asterisk indicates the significance threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001).')
```

## Guild weighted variances : nul model 2

```{r GWV3}
GWV <- L %>% 
  t() %>% 
  data.frame() %>% 
  filter(sum(.) > 2) %>% 
  mutate(SpCode = row.names(.)) %>% 
  left_join(Q) %>% 
  select(-SpCode) %>% 
  melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
       variable.name = 'community', value.name = 'abundance') %>% 
  melt(id.vars = c('strata', 'community', 'abundance'),
       variable.name = 'trait', value.name = 'trait_value') %>% 
  left_join(melt(GWM, id.vars = c('strata', 'community'),
                 variable.name = 'trait', value.name = 'GWM')) %>% 
  group_by(strata, community, trait) %>% 
  mutate(GWV = (trait_value - GWM)^2) %>% 
  select(-trait_value, -GWM) %>% 
  summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance) %>% 
  dcast(strata + community ~ trait)
# nL <- array(replicate(n, t(apply(L, 1, function(x){
#   x[x != 0] <- sample(x[which(x != 0)]) ; return(x)}))),
#   c(dim(L), n),
#   list(row.names(L), names(L), 1:n))
# cl <- makeCluster(cores)
# clusterExport(cl, list('nL', 'Q', 'GWM'))
# nGWV <- parApply(cl, nL, 3, function(x){
#   library(dplyr)
#   library(reshape2)
#   x %>%
#     t() %>%
#     data.frame() %>%
#     filter(sum(.) > 2) %>%
#     mutate(SpCode = row.names(.)) %>%
#     left_join(Q) %>%
#     select(-SpCode) %>%
#     melt(id.vars = c('strata', 'LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'LT'),
#          variable.name = 'community', value.name = 'abundance') %>%
#     melt(id.vars = c('strata', 'community', 'abundance'),
#          variable.name = 'trait', value.name = 'trait_value') %>%
#     left_join(melt(GWM, id.vars = c('strata', 'community'),
#                    variable.name = 'trait', value.name = 'GWM')) %>%
#     group_by(strata, community, trait) %>%
#     mutate(GWV = (trait_value - GWM)^2) %>%
#     select(-trait_value, -GWM) %>%
#     summarise_each(funs(weighted.mean(., abundance, na.rm = T)), -abundance) %>%
#     dcast(strata + community ~ trait)
# })
# stopCluster(cl)
# nGWV <- array(unlist(lapply(nGWV, function(x) as.matrix(x[3:9]))),
#               c(dim(GWV[3:9]), n),
#               list(row.names(GWV), names(GWV[3:9]), 1:n))
# GWV_ses <- GWV
# GWV_ses[3:9] <- (GWV[3:9] - apply(nGWV, 1:2, mean, na.rm = T))/apply(nGWV, 1:2, sd, na.rm = T)
# rm(cl, nL, nGWV)
# save(GWV_ses, file = file.path(path, 'GWV_ses.Rdata'))
load(file.path(path, 'GWV_ses.Rdata'))
GWV_ses %>% 
  melt(id.vars = c('strata', 'community')) %>% 
  rename(trait = variable) %>% 
  rename(SES = value) %>% 
  left_join(R) %>%
  select(-community) %>% 
  group_by(strata, trait) %>% 
  do(tidy(step(lm(SES ~ Slope + Curvature + Wetness + SW + Canopy + BA, .), 
          direction = 'both', trace = 0))) %>% 
  group_by(strata, trait, term) %>%
  transmute(value = paste(format(estimate, scientific = T, digits = 2, trim = T), 
                          stars(p.value, ns = '   '))) %>% 
  dcast(strata + trait ~ term) %>% 
  select(strata, trait, Slope, Curvature, Wetness, SW, Canopy, BA) %>% 
  mutate_each(funs(replace(., is.na(.), ' '))) %>% 
  bold() %>% 
  kable(caption = 'Linear models of the standardized effect sizes (SES) of GWV and CVNND, for canopy (C) and understorey (U) guilds. We performed stepwise selection of the predictors including slope, curvature, wetness southwesterness (SW), canopy height (Canopy) and basal area (BA), and only the selected predictors are shown. See table \\@ref(tab:Traits) for abbreviations. Bold and  number of asterisk indicates the significance threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001).')
```

# Supplementary materials

## Principal component analysis of environment

```{r PCAenv, fig.cap='Principal component analysis (PCA) performed on topgraphical variables. SW stand for southwesterness.'}
pca.env %>% 
  autoplot(colour = 'grey', loadings.label.size = 6,
           loadings.label.colour = 'black',
           loadings = T, loadings.label = T, 
           loadings.colour = 'black',
           loadings.label.vjust = 2) +
  coord_equal() +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  geom_vline(xintercept = 0, linetype = 'dashed') +
  xlab('Axe 1 − 42.52 %') + ylab('Axe 2 − 23.44 %')
```

# References {-}

---
title: 'Uppangala tree functional traits: Article draft'
author: Sylvain Schmitt sylvain.schmitt@agroparistech.fr
output: pdf_document
bibliography: refs.bib
---

```{r config, message=FALSE, warning=FALSE, include=FALSE}
library(knitr)
library(parallel)
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 8, fig.width = 8,
  cache = T, cache.lazy = F)
```

# Abstract

Keywords: functionnal trait, tropical evergreen forest, Western Ghats, India...

# Introduction

**To add:**

* Functional traits can be linked to trade-off in tree development strategy [@baraloto_decoupled_2010, and see table 1], and can be as well explained by environment condition. For instance, SLA is a soil fertility - shade index whereas LDMC will only be linked to soil fertility [@hodgson_is_2011].
* Leaf investment definition
* Leaf ressource acuisition definition
* Analyses scheme presentation:
    + Are functionnal composition of communities linked to the environment ?
        - Do covariations in functionnal traits illustrate ecological strategy axes ?
        - Are functionnal traits phylogenetically conserved ?
    + Are communities spatially structured ?
        - Are functionnal composition of communities spatially structured ?
        - Are phylogenetic composition of communities spatially structured ?

# Material and methods

## Study site

The study was carried out in the Kadamakal Reserve Forest (Kodagu District, Karnataka State, India), in the 10-ha "Uppangala plot" named after the nearest village. The permanent plot was established in 1990 by the French Institute of Pondicherry and described by @pascal_structure_1996. The Uppangala plot vegetation was assigned to low elevation *Dipterocarpus indicus - Kingiodendron pinnatum - Humboldtia brunonis* dense moist evergreen forest type [@pascal_wet_1988]. Climate and geology of the 10-ha plot can be considered as homogeneous. General topagraphy of the site shows a regular east-west alternation between thalwegs and ridges separated by relatively steep slopes, so that topography can be assumed as the major local abiotic factor which varies inside the plot [@gimaret-carpentier_sampling_1998]. Each tree girth is monitored by a two-year census.
**Girth monitoring to develop**

## Wood and leaf sampling

We collected trait information on 92 over 117 (79%) species focusing in priority on most abundant species with 5 replicates and we completed with less abundant and rare species with one to five replicates. Most abundant species were defined as the 32 species respresenting more than 80% of Uppangala tree individuals. Thus we generated data for 98.8% of the tree individuals present in the Uppangala plot. For each individual we collected 6 mature shadow dry leaves and one branch sample with a diameter close to 1cm following recommendation from @perez-harguindeguy_new_2013. Individuals and leaves were selected regarding their light condition, development stage and sanitary state for consistancy. Dawkins crown exposure index [@dawkins_management_1958] was registered to check the validity of the sampling. Leaf and branch samples were kept in humidified ziplock filled with enriched CO2 air inside a black bag untill their measurement in the following 24 hours. For some individuals we were unable to collect an appropriate branch sample (58 over 267 individuals representing 12 species over 91).

Leaf petioles, rachis and petiolules were removed for all measurements. Leaf fresh weights, area and thickness were measured, using a scanner [cite] and a microgauge [cite]. Leaves were first kept in herbarium and then dried in an oven for at least 72 hours at 60 degrees celsisus, the drying process was stopped after dry leaf weights were stable in time. Once dried the leaves were weighted directly after been removed from the oven to avoid humidity bias. The bark and pit of branch samples were removed in order to keep only branch wood with no soft tissues. Branch wood samples were sink in water to evaluate their volume by water displacement. Samples were then dried for 48 hours at 80 degrees celsius and weighted. 

## Trait measurements

We calculated five functionnal traits of leaf and wood samples: leaf thickness (Thick) measured in micrometer, leaf area (LA) measured from scans in $mm^2$, leaf dry matter content (LDMC) as the leaf dry weight in $mg$ divided by the leaf fresh weight in $g$,  specific leaf area (SLA) as the leaf area in $m^2$ divided by the leaf dry mass in $kg$, and branch wood density (WD) as the the wood sample dry weight in $g$ divided by wood sample volume in $cm^3$ (see table 1). 

Table 1: Functional traits measured. *Traits with their abbreviation, range of values in the sampling, mean and standard deviation, standard unit, and associated trade-off in tree development from @baraloto_decoupled_2010.*

```{r 1 Traits}
rm(list = ls()); invisible(gc())
library(Uppangala)
PFT <- genPFT()
captions <- genCaptions()
table <- data.frame(
  traits = c('Thickness', 'Leaf area', 'Leaf dry matter content', 'Specific leaf area', 'Wood density'),
  abbreviation = c('Thick', 'LA', 'LDMC', 'SLA', 'WD'),
  range = c(paste(range(PFT$Thick, na.rm = T), collapse = '-'),
            paste(round(range(PFT$LA, na.rm = T)), collapse = '-'),
            paste(round(range(PFT$LDMC, na.rm = T)), collapse = '-'),
            paste(round(range(PFT$SLA, na.rm = T), 2), collapse = '-'),
            paste(round(range(PFT$WD, na.rm = T), 2), collapse = '-')),
  `mean (sd)` = c(paste0(round(mean(PFT$Thick, na.rm = T)), ' (',
                         round(sd(PFT$Thick, na.rm = T)), ')'),
                  paste0(round(mean(PFT$LA, na.rm = T)), ' (',
                         round(sd(PFT$LA, na.rm = T)), ')'),
                  paste0(round(mean(PFT$LDMC, na.rm = T)), ' (',
                         round(sd(PFT$LDMC, na.rm = T)), ')'),
                  paste0(round(mean(PFT$SLA, na.rm = T),2), ' (',
                         round(sd(PFT$SLA, na.rm = T),2), ')'),
                  paste0(round(mean(PFT$WD, na.rm = T),2), ' (',
                         round(sd(PFT$WD, na.rm = T),2), ')')),
  unit = c('um', 'mm2', 'mg.g-1', 'm2.kg-1', 'g.cm-3'),
  strategy = c('Leaf defense vs. investment',
               'Leaf ressource capture vs.investment',
               'Leaf defense vs. investment',
               'Leaf ressource acquisiton vs. defense',
               'Stem transport, structure and defense')
  )
kable(table,  label="traits", row.names = F)
rm(table)
```

## Environmental variables

To study environment effect on our traits we choose 8 topographical variables representing abiotic factors: digital elevation model, slope, curvature, plan curvature, profile curvature, wetness (function of both slope and elevation representing water flow and accumulation areas), southwesterness (SW, aspect in direction of south-west), and distance to the nearest potential river. Digital elevation model is issued from a LIDAR campaign on Uppangala plots with a resolution of $1*1 m^2$. Slope, curvature, plan curvature, profile curvature, wetness and southwesterness ($cos(aspect~in~degres + 225)$) are all derived from the digital elevation model with the RSAGA package [@brenning_statistical_2008]. Distance to the nearest potential river was using ArcGis [@desktop_arcgis_2011].

In order to avoid multi-colinearity in future analyses, we reduced our abiotic factors explanatory variables via a principal component analysis (PCA), by keeping less correlated variables with the most ecological meaning to our judgement. We reduced our explanatory variables to slope, curvature, wetness and southwesterness, following PCA results (see supplementary materials S1).

To study biotic factors we choose 3 available variables: canopy height (canopy), basal area (BA), and stem density. Canopy height is calculated from a digital canopy model built with a LIDAR campaign on Uppangala **date ?** plots with a resolution $1*1 m^2$. Both basal area and stem density are calculated from 2013 girth inventory of Uppangala plot on stemw with a diameter above 10 centimeters at breast height ($DBH>10$). Consequently basal area end stem density are highly correlated (Spearman's $rho = 0.84$, $p-value < 0.001$). So we removed stem density to avoid multicolinearity, and we kept canopy height that was not correlated to basal area (Spearman's $rho = -0.09$, $p-value > 0.1$).

## Analyses

*Title are just here to help remembering the structure but might be removed*

### Functionnal composition of communities regarding environment

#### Covariation in traits

Traits variation was first investigated in three levels with the coefficient of variation ($cv = \frac{\sigma}{\mu}$ with $\sigma$ the standard deviation and $\mu$ the mean) between leaves of the same individual (intra-individual), between trees of the same species (intra-specific), and between species of the Uppangala plot (inter-specific).
Trait coefficients of variation analysis reveals a general increase of functionnal trait variation among scales (from intra-individual to inter-specific, see table 2). Whereas LA shows already high variablilty at intra-individual level almost as strong as the intra-specific variation ($CV_{individual} = 0.20$ and $CV_{species} = 0.24$, wilcoxon rank test $p-value = 0.137$). 

Table 2: Coefficient of intra-individual, intra-specific and inter-specific trait variation. *Mean of coefficient of variation for leaves in all individual (intra-individual), for trees in all species (intra-specific), and coefficient of variation for trees for all species. See table 1 for abbreviation.*

```{r 2 CV}
PFT_ind <- aggregate(PFT, by = list(PFT$Tree), FUN = mean, na.rm = T)
row.names(PFT_ind) <- PFT_ind$Group.1
SpT <- unique(PFT[1:2])
Sp <- SpT$SP
names(Sp) <- SpT$Tree
SpCodeT <- unique(PFT[2:3])
SpCode <- SpCodeT$Sp_Code
names(SpCode) <- SpCodeT$SP
CET <- unique(PFT[c(1,4)])
CE <- CET$CE
names(CE) <- CET$Tree
PFT_ind$SP <- Sp[row.names(PFT_ind)]
PFT_ind$Sp_Code <- SpCode[as.character(PFT_ind$SP)]
PFT_ind$CE <- CE[row.names(PFT_ind)]
PFT_ind <- PFT_ind[-c(1:2)]
cv <- data.frame(row.names = c('Thick', 'LA', 'LDMC', 'SLA', 'WD'))
cv$Individual <- unlist(lapply(
  as.list(row.names(cv)),
  function(y){mean(aggregate(PFT[which(names(PFT) ==  y)], by = list(PFT$Tree), function(x){sd(x, na.rm = T) / mean(x, na.rm = T)})[,2], na.rm = T)}))
cv$Species <- unlist(lapply(
  as.list(row.names(cv)),
  function(y){mean(aggregate(PFT_ind[which(names(PFT_ind) ==  y)], by = list(PFT_ind$SP), function(x){sd(x, na.rm = T) / mean(x, na.rm = T)})[,2], na.rm = T)}))
cv$Community <- unlist(
  lapply(as.list(row.names(cv)),
         function(y){sd(PFT[,which(names(PFT) ==  y)], na.rm = T) /
             mean(PFT[,which(names(PFT) ==  y)], na.rm = T)}))
cv <- round(cv, 2)
cv['WD','Individual'] <- ''
kable(cv)
rm(PFT, CET, cv, CE, Sp, SpT)
```

For the rest of the statistical analysis, we calculated the mean value of each 5 traits for our 92 species. To test the correlation and covariation among traits we performed a principal component analysis (PCA).

#### Community analysis

Among the whole 10 hectares plot from Uppangala, 240 spatial communities where defined with $20*20 m^2$ quadrats. To investigate traits distribution inside communities we used community weighted means (CWM), community weighted variances (CWV), and coefficients of variation from the nearest neighbour distance (CVNND) [CWM and CWV, sensu @violle_let_2007, CVNND, @jung_intraspecific_2010]. Analyses were conducted on the five functionnal traits and the two economic spectra defined with the species scores obtained on the 2 first PCA axes.

CWM for each trait $t$ was calculated as the mean of species trait values, $t_{i}$, of the $S$ species in each community, with each species, $i$, weighted by its relative
abundance, $p_{i}$:
$$CWM = \sum_{i=1}^{S} p_{i} * t_{i} ~ (1)$$
CWM was also computed in presence-absence, to get better insight of the role of rare species in community traits distribution. We tested links between CWMs and environment with a first null model randomizing traits among species (permuting raw in `Trait*Species` matrix). **Precise what this model imply**. Linear regressions between CWMs and biotic and abiotic factors after step measure were compared to corresponding 999 null linear regressions from our null models with F-statistic.

CWV for each trait $t$ was calculated as the difference between the mean of species trait values, $t_{i}$, and the $CWM$, of the $S$ species in each community, with each species, $i$, weighted by its relative
abundance, $p_{i}$:
$$CWV = \sum_{i=1}^{S} p_{i} * (t_{i} - CWM)^2 ~ (2)$$
We tested links between CWVs and environment with a second null model randomizing abundances among species inside each community but keeping the observed list of species and trait values inside communities. **Precise what this model imply**. The CWV standardized effect size (SES) was then computed comparing each community to their corresponding null communities with the formula :
$$SES = \frac{(CWV_{obs} - CWV_{null})}{\sigma _{null}}$$
where $CWV_{obs}$ is the observed CWV and $CWV_{null}$ and $\sigma _{null}$ are the mean and standard deviation of null distribution CWVs. Finally proportion of of CWVs differing from null expectaions was tested with a double tails test; and links between SES of CWVs and environment was investigated by linear regression. 

In parrallel to CWVs, eveness of communities was investigated with CVNND with the same null model randomizing abundances among species inside each community but keeping the observed list of species and trait values inside communities. SES were also calculated for CVNNDs. Finally proportion of of CVNNDs differing from null expectaions was tested with a double tails test; and links between SES of CVNNDs and environment was investigated by linear regression.

#### Phylogenetic signal

Phylogenetic tree of our 92 species was built with `S.PhyloMaker` function implemented by @qian_updated_2016-1.
Phylogenetic signal was globaly assessed for each functionnal trait among the phylogenetic tree by Moran's I statistic.
Phylogenetic signal structure was assessed by a tree tip distances correlogram.

### Spatial structure of community compositions

$\beta st$ and $\pi st$ metric proposed by @hardy_characterizing_2007 were used to investigate spatial structure of community phylogenetic compositions. Observed values were compared to the one obtained with the null model *"1s"*" suggested by @hardy_testing_2008 to see if we were under phylogenetic clustering or overdispersion.
In parrallel spatial structure of community functionnal composition was assessed by $U st$ and $\tau st$ metric proposed by @hardy_characterizing_2007. Observed values were compared to a null model randomizing traits among species (permuting raw in `Trait*Species` matrix).

All analysis were conducted in the R 3.3.0  free software environment for statistical analyses and graphics [@r_core_team_r:_2016] using the package 
`ade4` [@dray_ade4_2007], 
`ape` [@paradis_ape:_2004], 
`phylosignal` [@keck_phylosignal:_2015] 
and `spacodiR` [@eastman_spacodir:_2013].

# Results

## Functionnal composition of communities regarding environment

### Traits and environment

The multivariate analysis of trait correlation shows WD associated with structural leaf traits orthogonal to the SLA (see figure 1). The first PCA axis (PCA1) covary mainly with Thick, LDMC and WD; opposing thin and big leaves to dense leaves and wood. Whereas the second PCA axis (PCA2) covary mainly with SLA representative of the leaf economic spectrum [LES, @wright_worldwide_2004]. PCA first axis might be associated with the WD covariation to the wood economic spectrum [WES, @chave_towards_2009]. Results are similar to the one found by @fortunel_leaf_2012 where PCA1 and PCA2 were respectively interpreted as leaf and wood economic spectrum (inverted compare to us). Our results integrate less traits (5 against 14), and less species (92 against 758), but still capture the same strategy axes.

```{r 3 PCA PFT}
library(vegan)

PFT_ind$LA <- log(PFT_ind$LA)
PFT_ind$SLA <- log(PFT_ind$SLA)
PFT_ind$ID <- row.names(PFT_ind)
row.names(PFT_ind) <- PFT_ind$ID
PFT_ind <- PFT_ind[-which(names(PFT_ind) == 'ID')]
Species <- genSpecies()
PFT_sp <- aggregate(PFT_ind, by = list(PFT_ind$SP), FUN = mean, na.rm = T)
row.names(PFT_sp) <- PFT_sp$Group.1
PFT_sp$Sp_Code <- SpCode[row.names(PFT_sp)]
PFT_sp <- PFT_sp[-c(1:2,4)]
pca <- princomp(~ LA + WD + Thick + LDMC + SLA, data = PFT_sp, cor = T)

lambda <- pca$sdev * sqrt(nrow(pca$scores))
pca.var = apply(pca$score, 2, var)
PCAscores <- as.data.frame(pca$scores)[1:2] # Adding PCA axis in PFT values
names(PCAscores) <- c('WES', 'LES')
PCAscores$ID <- row.names(PCAscores)
plot(t(t(pca$scores)/lambda),pch=16, col = 'lightgrey',
     # xlab = paste('Axe 1 -', round(lambda[1]/sum(lambda)*100, 2), '%'),
     # ylab = paste('Axe 2 -', round(lambda[2]/sum(lambda)*100, 2), '%'))
     xlab = paste('Axe 1 -', round(pca.var[1]/sum(pca.var)*100, 2), '%'),
     ylab = paste('Axe 2 -', round(pca.var[2]/sum(pca.var)*100, 2), '%'))
# as.factor(Species[PFT_ind[row.names(pca$scores),2],6])
par(new=T)
Rot <- t(t(pca$loadings)*lambda)
XLIM <- c(-max(abs(Rot[,1])),max(abs(Rot[,1])))
XLIM <- XLIM+(XLIM*0.2)
plot(Rot,col=4,axes=FALSE,xlim=XLIM,ylim=XLIM,pch="",xlab = "", ylab = "")
lines(XLIM, c(0,0), lty = 2, col = 'firebrick', lwd = 2)
lines(c(0,0), XLIM, lty = 2, col = 'green', lwd = 2)
legend('topright', c('Leaf economic spectrum', 'Wood economic spectrum'),
       text.col = c("green", "firebrick"))

arrows (rep(0,nrow(pca$loadings)),rep(0,nrow(pca$loadings)),Rot[,1],Rot[,2],lwd=2)
text (Rot[,1:2], pos = c(4, 2, 4, 2, 3), rownames(Rot),cex=1.2)
Hmisc::subplot(function(){
  b <- barplot((pca.var / sum(pca.var)), las = 2, ylim = c(0,range(bstick(7))[2]),
          cex.names = 0.7, axes = T, names.arg = NA) ;
  lines(b, bstick(length(pca.var)), col = 'red') ;
  legend('topright', c('Eigen values', 'broken stick'), fill = c('grey', 'red'), cex = 0.6,
         box.col = 'white')},
  x=grconvertX(c(0.75,1), from='npc'),
  y=grconvertY(c(0.05,0.30), from='npc')
)
axis (3)
axis (4)

PCAscores <- as.data.frame(pca$scores)[1:2]
names(PCAscores) <- c('WES', 'LES')
PCAscores$ID <- row.names(PCAscores)
PFT_sp$ID <- row.names(PFT_sp)
PFT_sp <- merge(PFT_sp, PCAscores, all = T)
row.names(PFT_sp) <- PFT_sp$ID
PFT_sp <- PFT_sp[-which(names(PFT_sp) == 'ID')]
Q <- PFT_sp[c('LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'Thick')]
row.names(Q) <- PFT_sp$Sp_Code
rm(PCAscores, PFT_ind, SpCodeT, lambda, pca, pca.var, Rot, XLIM)
```

Figure 1: Principal component analysis (PCA) performed on species trait means. *Bottom right corner subplot represents the eigen values (grey bars) compare to a broken stick distribution for 6 components (red line). See table 1 for abbreviation.*

```{r 4 env-com}
library(raster)
Env <- genEnv()
Env$Rivers <- readAll(Env$Rivers)
Trees <- genTrees()
Trees$SpCode <- tolower(Trees$SpCode)
Trees$ID <- row.names(Trees)
Trees <- merge(Trees, PFT_sp, by.x = 'SpCode', by.y = 'Sp_Code')
row.names(Trees) <- Trees$ID
Trees <- Trees[-which(names(Trees) == 'ID')]
com <- quadrats()
Trees$com <- NA
XY <- data.frame(X = Trees$X, Y = Trees$Y)
XY <- XY[-which(is.na(XY$X)),] # Removing NA
coordinates(XY) <- ~ X + Y
proj4string(XY) <- crs(com)
Trees$com[which(!is.na(Trees$X))] <- (XY %over% com)[,1]
Trees$com[which(!is.na(Trees$com))] <- paste0('C', Trees$com[which(!is.na(Trees$com))])
com@data$id <- paste0('C', com@data$id)
com@data$Elevation <- extract(Env$DEM, as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
Deriv <- DEMderiv(raster(com, 'Elevation'), c('slope', 'curvature', 'plancurvature', 'profcurvature', 'cosaspect'))
names(Deriv)[5] <- 'SW'
com@data <- cbind(com@data, extract(Deriv, as(com, "SpatialPolygons"), df = T, fun = mean)[-1])
com@data$Wetness <- extract(DEMderiv(Env$DEM, 'wetness'), as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
com@data$Rivers <- extract(Env$Rivers, as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
com@data$Canopy <- extract(Env$Canopy, as(com, "SpatialPolygons"), df = T, fun = mean)[,2]
com@data$BA <- aggregate(Trees$`2013_girth`, list(Trees$com), function(x){sum(x, na.rm = T)/2*pi})[,2]
com@data$StD <- aggregate(rep(1, length(Trees$SpCode)), list(Trees$com), sum)[,2]
pca.env <- princomp(~ Elevation + Slope + Curvature + PlanCurvature + ProfileCurvature + Wetness + Rivers + SW, data = com@data, cor = T)
R <- com@data[c('Slope', 'Curvature', 'Wetness', 'SW', 'Canopy', 'BA')]
row.names(R) <- com@data$id
L <- data.frame(tapply(rep(1, length(Trees[,1])), list(Trees$com, Trees$SpCode), sum))
L[is.na(L)] <- 0
sel <- intersect(row.names(Q), names(L))
Q <- Q[sel,]
L <- L[sel]
R <- R[row.names(L),]
L <- list(abundance = L, `presence-absence` = L)
L$`presence-absence`[L$`presence-absence` > 1]  <- 1
rm(Deriv, XY, com, Env, Trees, sel, PFT_sp)
```

### Community analysis

Table 4: Summary of linear models and null models for traits community weighted means. _Linear model results for each trait community weighted means by species relative abundance after a variable selection by step mesure in both direction with slope, curvature, wetness, and southwesterness (SW), canopy height (Canopy) and basal area (BA). Model global and partial F-statistics were compared to 999 null model F-statistics in which traits were randomized among species. See table 1 for abbreviations. The number of asterisk indicate the p-value threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001)._

**Second table are the result in presence-absence. They are juste here for discussion. But they probably won't be in the final report under this shape.**

```{r CWM}
# Observed CWMs
CWM <- lapply(L, function(l){lapply(as.list(c('LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'Thick')), function(v){apply(l, 1, function(x){weighted.mean(Q[,v], x, na.rm=T)})})})
CWM <- lapply(CWM, function(x){names(x) <- c('LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'Thick') ; return(x)})
## Regressions
reg <- paste('~', paste(names(R), collapse = ' + '))
CWM.lm <- lapply(CWM, function(x){lapply(x, function(y){lm(y ~., R)})})
CWM.lm <- lapply(CWM.lm, function(y){lapply(y, function(x){step(x, direction = 'both', trace = 0)})})
## Global F
Fval <- lapply(CWM.lm, function(y){lapply(y, function(x){summary(x)$fstatistic['value']})})
Fval <- lapply(Fval, function(x){do.call('rbind.data.frame', x)})
Fval <- data.frame(Fval)
names(Fval) <- names(CWM.lm)
## Partial F
pFval <- lapply(CWM.lm, function(y){lapply(y, function(x){car::Anova(x)['F value']})})

# Simulated CWMs
n = 999
nQ <- rep(list(Q), n)
nQ <- lapply(nQ, function(x){row.names(x) <- sample(row.names(x)) ; return(x)})
nQ <- lapply(nQ, function(x){x[names(L$abundance),]})
cl <- makeCluster(3)
clusterExport(cl, list('L', 'nQ'))
nCWM <- clusterApply(cl, L, function(l){
  lapply(nQ, function(q){
    lapply(as.list(c('LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'Thick')), function(v){
      apply(l, 1, function(x){
        weighted.mean(q[,v], x, na.rm=T)
      })
    })
  })
})
stopCluster(cl)
rm(nQ, cl)
nCWM <- lapply(nCWM, function(y){lapply(y,function(x){names(x) <- c('LES', 'SLA', 'WES', 'WD', 'LDMC', 'LA', 'Thick') ; return(x)})})
## Regressions
nCWM.lm <- mapply(function(x,y){
  lapply(y, function(z){
    mapply(function(r,s){
      lm(formula(paste0('s ~ ', as.character(r$terms)[3])), cbind(s,R))
    }, r = x, s = z, SIMPLIFY = F)
  })
}, x = CWM.lm, y = nCWM, SIMPLIFY = F)
rm(nCWM) ; invisible(gc())
## Global F
nFval <- lapply(nCWM.lm, function(lm){lapply(lm, function(y){lapply(y, function(x){summary(x)$fstatistic['value']})})})
nFval <- lapply(nFval, function(x){lapply(x, `[`, names(x[[1]])) ; apply(do.call(rbind, x), 2, as.list)})
nFval <- lapply(nFval, function(f){lapply(f, unlist)})
pval <- 1 - mapply(function(x,y){mapply(function(r,s){rank(c(r,s))[1]/(n+1)}, r = x, s= y)}, x = lapply(as.list(Fval), as.list), y = nFval)
row.names(pval) <- row.names(Fval)
rm(Fval, nFval)
# Partial F
npFval <- lapply(nCWM.lm, function(lm){lapply(lm, function(y){lapply(y, function(x){car::Anova(x)['F value']})})})
npFval <- lapply(npFval, function(x){lapply(x, `[`, names(x[[1]])) ; apply(do.call(rbind, x), 2, as.list)})
npFval <- lapply(npFval, function(f){lapply(f, function(x){do.call('cbind', x)})})
ppval <- mapply(function(x,y){mapply(function(r,s){mapply(function(p,q){rank(c(p,q))[1]/(n+1)}, p = as.list(data.frame(t(r))), q = as.list(data.frame(t(s))))}, r = x, s = y)}, x = pFval, y = npFval, SIMPLIFY = F)
ppval <- lapply(ppval, function(y){lapply(y, function(x){data.frame(t(x))})})
ppval <- lapply(ppval, function(y){data.frame(data.table::rbindlist(y, fill = T))})
ppval <- lapply(ppval, function(y){row.names(y) <- names(CWM.lm$abundance) ; return(y)})
ppval$abundance <- ppval$abundance[c('Slope', 'Curvature', 'Wetness', 'SW', 'Canopy')]
ppval$abundance$BA <- NA
ppval$`presence-absence` <- ppval$`presence-absence`[c('Slope', 'Curvature', 'Wetness', 'SW', 'Canopy', 'BA')]
ppval <- lapply(ppval, function(x){1 - x})
rm(pFval, npFval)

# Result tables
kable(regression_table(CWM.lm[[1]], reg, pval[,1], ppval[[1]]))
kable(regression_table(CWM.lm[[2]], reg, pval[,2], ppval[[2]]))
rm(CWM.lm, nCWM.lm, pval, ppval, reg) ; invisible(gc())
```

Table 5: Summary of linear models for traits standardized effect size of community weighted variances. _Linear model results for each trait standardized effect size of community weighted variances species relative abundance after a variable selection by step mesure in both direction with slope, curvature, wetness, and southwesterness (SW), canopy height (Canopy) and basal area (BA). See table 1 for abbreviations. The number of asterisk indicate the p-value threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001)._

**First output is the result of two tails test on communities CWVs for each traits. They are juste here for discussion. But they probably won't be in the final report under this shape.**

```{r CWV, fig.height=4}
# Observed CWVs
CWV <- lapply(names(CWM$abundance), function(v){apply(cbind(data.frame(CWM$abundance[[which(names(CWM$abundance) == v)]]),L$abundance), 1, function(x){sqrt(weighted.mean((Q[,v]-x[1])^2, x[-1], na.rm=T))})})
names(CWV) <- names(CWM$abundance)

# Simulated CWVs 
nL <- rep(list(L$abundance), n)
nL <- lapply(nL,function(l){apply(l, 1, function(x){x[x != 0] <- sample(x[x != 0]) ; return(x)})}) 
nL <- lapply(nL, function(x){t(x)})
nL <- lapply(nL, data.frame)

cl <- makeCluster(3)
clusterExport(cl, list('nL', 'CWM', 'Q'))
nCWM.cwv <- clusterApply(cl, nL, function(l){
  lapply(as.list(names(CWM$abundance)), function(v){
    apply(l, 1, function(x){
      weighted.mean(Q[,v], x, na.rm=T)
    })
  })
})
stopCluster(cl)
nCWM.cwv <- lapply(nCWM.cwv, function(x){names(x) <- names(CWM$abundance) ; return(x)})
nCWV <- mapply(function(l,cwm){
  lapply(names(CWM$abundance), function(v){
    apply(cbind(data.frame(cwm[[which(names(cwm) == v)]]),l), 1, function(x){
      sqrt(weighted.mean((Q[,v]-x[1])^2, x[-1], na.rm=T))
    })
  })
}, l = nL, cwm = nCWM.cwv, SIMPLIFY = F)
nCWV <- lapply(nCWV, function(x){names(x) <- names(CWM$abundance) ; return(x)})
rm(nCWM.cwv, cl)
# ## Regressions
# nCWV.lm <- lapply(nCWV, function(cwv){
#   mapply(function(x,y){
#     lm(formula(paste0('y ~ ', as.character(x$terms)[3])), cbind(y,R))
#   }, x = CWV.lm, y = cwv, SIMPLIFY = F)
# })
## Non null CWVs
nCWV <- lapply(nCWV, `[`, names(nCWV[[1]]))
nCWV <- apply(do.call(rbind, nCWV), 2, as.list)
nCWV <- lapply(nCWV, function(x){do.call('cbind', x)})
nCWV <- lapply(nCWV, data.frame)
CWV.pval <- data.frame(mapply(function(x,y){
  mapply(function(p,q){
    rank(c(p,q))[1]/(n+1)
  }, p = as.list(x), q = as.list(data.frame(t(y))))
}, x = CWV, y = nCWV))
CWV.pval.res <- data.frame(inf = apply(CWV.pval, 2, function(x){length(which(x < 0.025))/length(x)}), sup = apply(CWV.pval, 2, function(x){length(which(x > 0.975))/length(x)}))
## CWV SES
CWV.ses <- data.frame(mapply(function(x,y){
  mapply(function(p,q){
    (p - mean(q))/sd(q)
  }, p = as.list(x), q = as.list(data.frame(t(y))))
}, x = CWV, y = nCWV))
CWV.ses.lm <- apply(CWV.ses, 2, function(y){lm(y ~., R)})
CWV.ses.lm <- lapply(CWV.ses.lm, function(x){step(x, direction = 'both', trace = 0)})
CWV.ses.res <- lapply(CWV.ses.lm, function(x){summary(x)$coefficients})
CWV.ses.res <- lapply(CWV.ses.res, data.frame)
CWV.ses.res <- lapply(CWV.ses.res, function(x){x$res <- paste(format(x$Estimate, scientific = T, digits = 2), apply(x[4], 1, stars, ns = '   ')) ; return(x)})
CWV.ses.res <- data.frame(data.table::rbindlist(lapply(CWV.ses.res, function(x){data.frame(t(x[5]))}), fill = T))
CWV.ses.res <- CWV.ses.res[-1]
CWV.ses.res$Curvature <- NA
CWV.ses.res <- CWV.ses.res[c('Slope', 'Curvature', 'Wetness', 'SW', 'Canopy', 'BA')]
CWV.ses.res <- apply(CWV.ses.res, 2, as.character)
row.names(CWV.ses.res) <- names(CWV.ses)
CWV.ses.res[is.na(CWV.ses.res)] <- ''
CWV.ses.res <- data.frame(CWV.ses.res)
CWV.ses.res$R2 <- round(unlist(lapply(CWV.ses.lm, function(x){summary(x)$r.squared})),3)

# Results
barplot(t(CWV.pval.res), las = 2, col = c('darkblue', 'firebrick'), ylim = c(0,1), ylab = 'Proportion of non null communities') ; legend('topright', c('Inferior','Superior'), fill = c('darkblue', 'firebrick'))
kable(CWV.ses.res)
rm(CWV.pval, CWV.pval.res, CWV.ses.res, CWV.ses.lm, nCWV)
```

Table 6: Summary of linear models for traits standardized effect size of coefficient of variation of nearest neighbour distances. _Linear model results for each trait standardized effect size of coefficient of variation of nearest neighbour distances after a variable selection by step mesure in both direction with slope, curvature, wetness, and southwesterness (SW), canopy height (Canopy) and basal area (BA). See table 1 for abbreviations. The number of asterisk indicate the p-value threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001)._

**First output is the result of two tails test on communities CWVs for each traits. They are juste here for discussion. But they probably won't be in the final report under this shape.**

```{r CVNND, fig.height=4}
# Observed CVNND
CVNND <- apply(L$abundance, 1, function(l){apply(Q, 2, function(q){cati::CVNND(rep(q, l), na.rm = T)})})

# Simulated CVNNDs 
cl <- makeCluster(3)
clusterExport(cl, list('nL', 'Q'))
nCVNND <- clusterApply(cl, nL, function(x){
  apply(x, 1, function(l){
    apply(Q, 2, function(q){
      cati::CVNND(rep(q,l), na.rm = T)
    })
  })
})
stopCluster(cl) ; rm(cl)
rm(nL) ; invisible(gc)
## Non null CVNNDs
nCVNND <- lapply(nCVNND, function(x){as.list(data.frame(t(x)))})
nCVNND <- lapply(nCVNND, function(x){lapply(x, function(y){names(y) <- colnames(CVNND) ; return(y)})})
nCVNND <- lapply(nCVNND, `[`, names(nCVNND[[1]]))
nCVNND <- apply(do.call(rbind, nCVNND), 2, as.list)
nCVNND <- lapply(nCVNND, function(x){do.call('cbind', x)})
nCVNND <- lapply(nCVNND, data.frame)
CVNND.pval <- data.frame(mapply(function(x,y){
  mapply(function(p,q){
    rank(c(p,q))[1]/(n+1)
  }, p = as.list(x), q = as.list(data.frame(t(y))))
}, x = as.list(data.frame(t(CVNND))), y = nCVNND))
row.names(CVNND.pval) <- colnames(CVNND)
CVNND.pval.res <- data.frame(inf = apply(CVNND.pval, 2, function(x){length(which(x < 0.025))/length(x)}), sup = apply(CVNND.pval, 2, function(x){length(which(x > 0.975))/length(x)}))
## CVNND SES
CVNND.ses <- data.frame(mapply(function(x,y){
  mapply(function(p,q){
    (p - mean(q))/sd(q)
  }, p = as.list(x), q = as.list(data.frame(t(y))))
}, x = as.list(data.frame(t(CVNND))), y = nCVNND))
row.names(CVNND.ses) <- colnames(CVNND)
CVNND.ses.lm <- apply(CVNND.ses, 2, function(y){lm(y ~., R)})
CVNND.ses.lm <- lapply(CVNND.ses.lm, function(x){step(x, direction = 'both', trace = 0)})
CVNND.ses.res <- lapply(CVNND.ses.lm, function(x){summary(x)$coefficients})
CVNND.ses.res <- lapply(CVNND.ses.res, data.frame)
CVNND.ses.res <- lapply(CVNND.ses.res, function(x){x$res <- paste(format(x$Estimate, scientific = T, digits = 2), apply(x[4], 1, stars, ns = '   ')) ; return(x)})
CVNND.ses.res <- data.frame(data.table::rbindlist(lapply(CVNND.ses.res, function(x){data.frame(t(x[5]))}), fill = T))
CVNND.ses.res <- CVNND.ses.res[-1]
CVNND.ses.res$Curvature <- NA
CVNND.ses.res <- CVNND.ses.res[c('Slope', 'Curvature', 'Wetness', 'SW', 'Canopy', 'BA')]
CVNND.ses.res <- apply(CVNND.ses.res, 2, as.character)
row.names(CVNND.ses.res) <- names(CVNND.ses)
CVNND.ses.res[is.na(CVNND.ses.res)] <- ''
CVNND.ses.res <- data.frame(CVNND.ses.res)
CVNND.ses.res$R2 <- round(unlist(lapply(CVNND.ses.lm, function(x){summary(x)$r.squared})),3)

# Results
barplot(t(CVNND.pval.res), las = 2, col = c('darkblue', 'firebrick'), ylim = c(0,1), ylab = 'Proportion of non null communities') ; legend('topright', c('Inferior','Superior'), fill = c('darkblue', 'firebrick'))
kable(CVNND.ses.res)
rm(CVNND.pval, CVNND.pval.res, CVNND.ses.res, CVNND.ses.lm, nCVNND) ; invisible(gc())
```

### Phylogenetic signal

**Artefacts of phylogenetic tree building to be removed**

```{r PhyloMaker}
library(phylosignal)
library(phytools)
library(phylobase)

# Building species list
l <- PFT_sp
# setdiff(row.names(l), Species$LatinName)
row.names(l)[which(row.names(l) == 'Actinodaphne tadulingami')] <- 'Actinodaphne tadulingamii'
Species['agin',] <- c('agin', "Agrostistachys indica", 'Euphorbiaceae', NA, NA)
Species['anme',] <- c('anme', "Antidesma menasu", 'Euphorbiaceae', NA, NA)
Species['anmo',] <- c('anme', "Antidesma montanum", 'Euphorbiaceae', NA, NA)
row.names(l)[which(row.names(l) == 'Blepharistemma membranifolia')] <- 'Blepharistemma serratum '
row.names(l)[which(row.names(l) == 'Casearia ovata')] <- 'Casearia ovata '
row.names(l)[which(row.names(l) == 'Cinnamomum malabathrum')] <- 'Cinnamomum malabatrum'
row.names(l)[which(row.names(l) == 'Cinnamomum sp1')] <- 'Cinnamomum sp.'
row.names(l)[which(row.names(l) == 'Dimocarpus longan')] <- 'Dimocarpus longan '
row.names(l)[which(row.names(l) == 'Drypetes confertiflorus')] <- 'Drypetes confertiflora'
row.names(l)[which(row.names(l) == 'Glochidion malabaricum')] <- 'Glochidion ellipticum'
row.names(l)[which(row.names(l) == 'Homalium zeylanicum')] <- 'Homalium zeylanicum '
row.names(l)[which(row.names(l) == 'Ixora nigricams')] <- 'Ixora nigricans  '
row.names(l)[which(row.names(l) == 'Knema attenuata')] <- 'Knema attenuata  '
row.names(l)[which(row.names(l) == 'Leptonychia moacurroides')] <- 'Leptonychia caudata '
row.names(l)[which(row.names(l) == 'Myristica malabarica')] <- 'Myristica malabarica '
row.names(l)[which(row.names(l) == 'Olea dioica')] <- 'Olea dioica '
row.names(l)[which(row.names(l) == 'Reinwardtiodendron anaimalaiense')] <- 'Reinwardtiodendron anamalaiense'
row.names(l)[which(row.names(l) == 'Strombosia ceylanica')] <- 'Strombosia ceylanica '
row.names(l)[which(row.names(l) == 'Symplocos cochinensis')] <- 'Symplocos cochinchinensis'
row.names(l)[which(row.names(l) == 'Syzygium laetum')] <- 'Syzygium laetum '
row.names(l)[which(row.names(l) == 'Vepris bilocularis')] <- 'Vepris bilocularis '
sp <- Species[which(Species$LatinName %in% row.names(l)), 2:3]
sp$genus <- unlist(lapply(strsplit(sp$LatinName, ' ', fixed = T), function(x){x[1]}))
sp$species <- sub(' ', '_', sp$LatinName, fixed = T)
sp$family <- sp$Family
sp <- sp[c('species', 'genus', 'family')]
sp[which(sp$family == 'Flacourtiaceae'),3] <- 'Salicaceae'
sp[which(sp$family == 'Steruliaceae'),3] <- 'Malvaceae'
sp[which(sp$family == 'Cesaliniaceae'),3] <- 'Fabaaceae'
sp['hepa','family'] <- 'Malvaceae'
# sp <- sp[-which(row.names(sp) == 'hubr'),]
# sp <- sp[-which(row.names(sp) %in% levels(droplevels(PFT_sp[which(is.na(PFT_sp$WD)),1]))),]

# Getting phylogeny
path <- system.file('phylogeny', package = 'Uppangala')
source(file.path(path, 'R_codes for function S.PhyloMaker.txt'))
phylo <- read.tree(file.path(path, 'PhytoPhylo.tre'))
nodes <- read.csv(file.path(path, 'nodes.csv'), h = T)
results <- S.PhyloMaker(sp, phylo, nodes)
tree <- results$Scenario.1
```

Table 7: Summary of Moran’s I statistic and p-values for phylogenetic signal of functionnal traits. _See table 1 for abbreviations. The number of asterisk indicate the p-value threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001)._

```{r Phylosignal}
data <- l
row.names(data) <- gsub(' ', '_', row.names(data), fixed = T)
tips <- row.names(data)[which(is.na(l$WD))]
phy <- list(full = drop.tip(tree, tips), `-WD` = tree)
data <- list(full = data[phy$full$tip.label,c(2:5,7)], `-WD` = data[phy$`-WD`$tip.label,c(3:5,7)])
p4d <- mapply(function(p,d){phylo4d(p,d)}, p = phy, d = data)
# lapply(p4d, barplot)
phyloS <- lapply(p4d, phyloSignal, methods = 'I')
phyloS <- lapply(phyloS, function(x){cbind(x$stat, x$pvalue)})
phyloS <- rbind(phyloS$`-WD`, phyloS$full['WD',])
names(phyloS) <- c('Moran\'s I', 'p-value')
phyloS$` ` <- lapply(as.list(phyloS$`p-value`), stars)
phyCor <- mapply(function(d,p){lapply(as.list(names(d)), function(x){phyloCorrelogram(p, trait = as.character(x))})}, d = data, p = p4d)
phyCor <- c(phyCor$`-WD`, list(phyCor$full[[1]]))
names(phyCor) <- unlist(lapply(phyCor, function(x){x$trait}))
lipa <- lapply(p4d, lipaMoran)
# mapply(function(x,y){barplot.phylo4d(x, bar.col=(y$p.value < 0.05) + 1)}, x = p4d, y = lipa)
kable(phyloS)
```

## Spatial structure of community compositions

Spatial structure of both community phylogenetic and functionnal communities don't show significant organization, no convergence nor divergence ($U_{st} = -1.1*10^-3$ with $p-value = 0.114$, $\tau _{st} = 1.8*10^-3$ with $p-value = 0.079$, $\beta _{st} = -8.3*10^-4$ with $p-value = NaN$, and $\pi _{st} = -1.8*10^-3$ with $p-value = 0.247$).  

**Following tables will probably be removed in final report by simply including results in text. They are juste here for discussion.**

Table 8: Summary of spatial structure of community functionnal compositions. _$U st$ and $\tau st$ metric proposed by @hardy_characterizing_2007 were used to investigate spatial structure of community phylogenetic compositions. Observed values were compared to the one obtained with the null model *"1s"*" suggested by @hardy_testing_2008. The number of asterisk indicate the p-value threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001)._

```{r Functionnal spatial structure}
library(spacodiR)

# Traits structure
Lm <- data.frame(tapply(rep(1, length(Trees[,1])), list(Trees$com, Trees$SpCode), sum))
Lm[is.na(Lm)] <- 0
Lm.l <- list(full = Lm, `-WD` = Lm)
Qm <- PFT_sp[c('SLA', 'LDMC', 'WD', 'Thick', 'LA')]
row.names(Qm) <- PFT_sp$Sp_Code
Qm.l <- list(full = Qm, `-WD` = Qm[-3])
Qm.l <- mapply(function(x,y){x[intersect(row.names(x), names(y)),]}, x = Qm.l, y = Lm.l, SIMPLIFY = F)
Qm.l$full <- Qm.l$full[-which(is.na(Qm.l$full$WD)),]
Lm.l <- mapply(function(x,y){y[intersect(row.names(x), names(y))]}, x = Qm.l, y = Lm.l, SIMPLIFY = F)
spafun <- mapply(function(x,y){spacodi.calc(sp.plot = t(y), sp.traits = x)}, x = Qm.l, y = Lm.l, SIMPLIFY = F)
spafun <- do.call('rbind.data.frame', lapply(spafun, function(x){x[1:4]}))

Qm.lRD <- lapply(Qm.l, function(x){rep(list(x),999)})
Qm.lRD <- lapply(Qm.lRD, function(x){lapply(x, function(y){y[sample(row.names(y)),]})})
Lm.lRD <- lapply(Lm.l, function(x){rep(list(x),999)})
Lm.lRD <- mapply(function(x,y){mapply(function(r,s){r[row.names(s)]}, r = x, s = y, SIMPLIFY = F)}, x = Lm.lRD, y = Qm.lRD, SIMPLIFY = F)
spafun.l <- mapply(function(x,y){mapply(function(r,s){spacodi.calc(sp.plot = t(s), sp.traits = r)}, r = x, s = y, SIMPLIFY = F)}, x = Qm.lRD, y = Lm.lRD, SIMPLIFY = F)
spafun.l <- lapply(spafun.l, function(x){lapply(x, function(y){y[1:4]})})
spafunRD <- list(Ist = lapply(spafun.l, function(x){unlist(lapply(x, function(y){y$Ist}))}),
                 Tst = lapply(spafun.l, function(x){unlist(lapply(x, function(y){y$Tst}))}),
                 Ust = lapply(spafun.l, function(x){unlist(lapply(x, function(y){y$Ust}))}),
                 TAUst = lapply(spafun.l, function(x){unlist(lapply(x, function(y){y$TAUst}))}))
pvalues <- mapply(function(obs,rd){
  mapply(function(o,r){rank(c(o, r))[1]/1000}, o = obs, r = rd)
  }, obs = lapply(as.list(spafun), as.list), rd = spafunRD)
row.names(pvalues) <- row.names(spafun)

pvalues <- as.data.frame(pvalues)[3:4]
pvalues$Ust <-  1- pvalues$Ust
spafun.res <- format(spafun[3:4], scientific = T, digits = 2)
pvalues <- data.frame(apply(pvalues, c(1,2), function(y){paste(y, stars(y, ns = ' '))}))
spafun.res$Ust <- paste(spafun.res$Ust, '/', pvalues$Ust)
spafun.res$TAUst <- paste(spafun.res$TAUst, '/', pvalues$TAUst)
kable(spafun.res)
```

Table 9: Summary of spatial structure of community phylogenetic compositions. _$\beta st$ and $\pi st$ metric proposed by @hardy_characterizing_2007 were used to investigate spatial structure of community phylogenetic compositions. Observed values were compared to a null model randomizing traits among species (permuting raw in `Trait*Species` matrix). The number of asterisk indicate the p-value threshold ( * p-value<0.05, ** p-value <0.01, *** p-value<0.001)._

```{r Phylogenetic spatial structure}
for(i in 1:2) phy[[i]]$tip.label <- gsub('_', ' ', phy[[i]]$tip.label, fixed = T)
for(i in 1:2) phy[[i]]$tip.label <- as.character(l$Sp_Code[match(phy[[i]]$tip.label, row.names(l))])
Lm <- lapply(phy, function(x){Lm[intersect(names(Lm), x$tip.label)]})
phyRD <- lapply(phy, function(x){x$node.label <- NULL ; return(x)})
phyRD <- lapply(phyRD, function(x){rep(list(x), 999)})
phyRD <- lapply(phyRD, function(x){lapply(x, resamp.phy)})
LmRD <- lapply(Lm, function(x){rep(list(x), 999)})
LmRD <- mapply(function(x,y){mapply(function(r,s){r[intersect(names(r), s$tip.label)]}, r = x, s = y, SIMPLIFY = F)}, x = LmRD, y = phyRD, SIMPLIFY = F)
phyRD <- mapply(function(x,y){mapply(function(r,s){drop.tip(r, setdiff(r$tip.label, names(s)))}, r = x, s= y, SIMPLIFY = F)}, x = phyRD, y = LmRD, SIMPLIFY = F)

spaphy <- mapply(function(x,y){spacodi.calc(sp.plot = t(y), phy = x)}, x = phy, y = Lm.l, SIMPLIFY = F)
spaphy <- do.call('rbind.data.frame', lapply(spaphy, function(x){x[1:4]}))

spaphy.l <- mapply(function(x,y){mapply(function(r,s){spacodi.calc(t(r), s)}, r = x, s = y, SIMPLIFY = F)},x = LmRD, y = phyRD, SIMPLIFY = F)
spaphy.l <- lapply(spaphy.l, function(x){lapply(x, function(y){y[1:4]})})
spaphyRD <- list(Ist = lapply(spaphy.l, function(x){unlist(lapply(x, function(y){y$Ist}))}),
                 Tst = lapply(spaphy.l, function(x){unlist(lapply(x, function(y){y$Tst}))}),
                 Bst = lapply(spaphy.l, function(x){unlist(lapply(x, function(y){y$Bst}))}),
                 PIst = lapply(spaphy.l, function(x){unlist(lapply(x, function(y){y$PIst}))}))
pvalues <- mapply(function(obs,rd){
  mapply(function(o,r){rank(c(o, r))[1]/1000}, o = obs, r = rd)
  }, obs = lapply(as.list(spaphy), as.list), rd = spaphyRD)
row.names(pvalues) <- row.names(spaphy)

pvalues <- as.data.frame(pvalues)[3:4]
pvalues$Bst <-  rep(NaN,2)
spaphy.res <- format(spaphy[3:4], scientific = T, digits = 2)
pvalues <- data.frame(apply(pvalues, c(1,2), function(y){paste(y, stars(y, ns = ' '))}))
spaphy.res$Bst <- paste(spaphy.res$Bst, '/', pvalues$Bst)
spaphy.res$PIst <- paste(spaphy.res$PIst, '/', pvalues$PIst)
kable(spaphy.res)

# permut <- list(Bst = mapply(function(x,y){spacodi.by.nodes(sp.plot = t(y), x, sp.parm = "Bst", method = "1s")}, x = phy, y = Lm.l, SIMPLIFY = F), PIst = mapply(function(x,y){spacodi.by.nodes(sp.plot = t(y), x, sp.parm = "PIst", method = "1s")}, x = phy, y = Lm.l, SIMPLIFY = F))
# par(mfrow=c(2,2)) ; invisible(lapply(permut, function(x){lapply(x, spacodi.permutplot)}))
```

# Discussion

# *Acknowledgement*

# Supplementary materials

**I'm aware that Supplementary materials goes after References (as figure and tables), but it's not possible for the moment with Rmarkdown and knitr.**

## S1: Principal component analysis performed on topgraphical variables

Curvature covary with profile curvature, plan curvature, distance to potential rivers and the PCA first axis. Elevation and wetness are opposed in the principal component analysis and slope and south-westerness doesn't seem to covary much with other variables.

```{r PCA Env}
lambda <- pca.env$sdev * sqrt(nrow(pca.env$scores))
pca.env.var = apply(pca.env$score, 2, var)
plot(t(t(pca.env$scores)/lambda),pch=16, col = 'lightgrey',
     xlab = paste('Axe 1 -', round(pca.env.var[1]/sum(pca.env.var)*100, 2), '%'),
     ylab = paste('Axe 2 -', round(pca.env.var[2]/sum(pca.env.var)*100, 2), '%'))
Hmisc::subplot(function(){
  b <- barplot((pca.env.var / sum(pca.env.var)), las = 2,
          cex.names = 0.7, axes = T, names.arg = NA) ;
  lines(b, bstick(length(pca.env.var)), col = 'red') ;
  legend('topright', c('Eigen values', 'broken stick'), fill = c('grey', 'red'), cex = 0.6,
         box.col = 'white')},
  x=grconvertX(c(0.07,0.37), from='npc'),
  y=grconvertY(c(0.025,0.30), from='npc')
)
par(new=T)
Rot <- t(t(pca.env$loadings)*lambda)
XLIM <- c(-max(abs(Rot[,1])),max(abs(Rot[,1])))
XLIM <- XLIM+(XLIM*0.2)
plot(Rot,col=4,axes=FALSE,xlim=XLIM,ylim=XLIM,pch="",xlab = "", ylab = "")
lines(XLIM, c(0,0), lty = 2, lwd = 2)
lines(c(0,0), XLIM, lty = 2, lwd = 2)
col <- c("#1874CD", "#008B00", "#CD3700", "#9400D3")[c(2, 3, 1, 1, 1,  2, 1, 4)]
arrows (rep(0,nrow(pca.env$loadings)),rep(0,nrow(pca.env$loadings)),
        Rot[,1],Rot[,2],lwd=2,col=col)
legend('topright', c('Elevation', 'Slope', 'Water flow', 'South-West'),
       text.col = col, cex = 1.2)
text (Rot[,1:2], pos = c(2, 2, 2, 1, 1, 3, 3, 4), rownames(Rot),cex=1.2,col=col)
axis (3)
axis (4)
```

Supplementary material S1: Principal component analysis (PCA) performed on topgraphical variables. *Bootom left corner subplot represents the eigen values (grey bars) compare to a broken stick distribution for 8 components (red line). SW stand for southwesterness.*

## S2: Structural equation model

In order to see if or if environmental biotic factors were the results of functionnal traits we used structural equation modelling. Three latent variables were defined: *Abiotic environment* defined with selected topographical variables, *Biotic environment* defined with our 2 selected biotic variables, and *Functionnal traits* defined with our 5 functionnal traits. Two models were compared, a first one with the functionnal traits explained by both abiotic and biotic factors (**m1** *Traits ~ Abiotic + Biotic*), and a second one with the biotic factors explained by the functionnal traits and abiotic factors (**m2** *Biotic ~ Traits + Abiotic*). Models were compared with a Chi Square Difference test on Aikaike's Criterion Indice (AIC). 

Structural equation modelling (SEM) revealed that environmental biotic factors were influencing functionnal traits and not the contrary. Effectively retained model was the first one (**m1** *Traits ~ Abiotic + Biotic*, see supplementary material S1) with a significantly lower AIC on Chi Square Difference test ($AIC = 13195$ against $AIC = 13238$ with $p.value < 0.001$).

```{r SEM}
library(lavaan)
m1 <- '
Abiotic =~ Slope + Curvature + Wetness + SW
Traits =~ WD.cwm + Thick.cwm + LA.cwm + LDMC.cwm + SLA.cwm
Biotic =~ BA + Canopy
Traits ~ Abiotic + Biotic
'
m2 <- '
Abiotic =~ Slope + Curvature + Wetness + SW
Traits =~ WD.cwm + Thick.cwm + LA.cwm + LDMC.cwm + SLA.cwm
Biotic =~ BA + Canopy
Biotic ~ Traits + Abiotic
'
fit1 <- sem(m1, data = com$abundance@data)
fit2 <- sem(m2, data = com$abundance@data)
semPlot::semPaths(fit1,
                  what = 'col',
                  whatLabels = 'std',
                  style = 'lisrel',
                  residuals = T,
                  nCharNodes = 0,
                  nCharEdges = 0,
                  groups='manlat',
                  pastel = T,
                  ask = F)
```

Supplementary material S2: Path diagram for structural equation modelling. *Path diagram of the structural equation model* **m1** *Traits ~ Abiotic + Biotic. Arrow values are indicating standardized parameter estimates*.

## S3: Phylogenetic signal among functionnal traits by correlogram

```{r phylosignal plots}
par(mfrow = c(2,4))
for(i in 1:length(names(data))) plot(phyCor[[i]], main = names(data)[i])
```

Supplementary materials S3: Correlogram of phylogenetic signal among the 5 functionnal traits.

# References
